// ==UserScript==
// @name         Robotics
// @author       Oe
// @description  Idk Testing Smth
// @version      1.8
// @match        *://*.moomoo.io/*
// @grant        none
// ==/UserScript==

// Rugo Ruggy aeaeaeae
var sin = Math.sin,
    cos = Math.cos,
    abs = Math.abs,
    atan2 = Math.atan2,
    sqrt = Math.sqrt,
    round = Math.round,
    ceil = Math.ceil,
    floor = Math.floor,
    pow = Math.pow,
    min = Math.min,
    max = Math.max,
    random = Math.random,
    pi = Math.PI,
    pi2 = pi*2,
    pi_2 = pi/2,
    pi_3 = pi/3,
    pi_4 = pi/4

let Moddo = {
    main: () => {
        "use strict";
        let getEl = (id) => document.getElementById(id);
        let io = Moddo.client.io;
        io.debug = false; // for debugging packets
        let Utils = Moddo.modules.Utils;
        let config = Moddo.modules.config;
        let textManager = new Moddo.modules.TextManager();
        var vultrClient = new Moddo.client.vultrClient("moomoo.io", 3000, config.maxPlayers, 5, false);

        class AltchaManager {
            constructor() {
                this.altchaCode;
                this.selfFunc = self.URL || self.webkitURL;
                this.workerBlob = this.baseEncoded = "IWZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2xldCBlPW5ldyBUZXh0RW5jb2Rlcjthc3luYyBmdW5jdGlvbiB0KHQsbixyKXt2YXIgbDtyZXR1cm4gbD1hd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdChyLnRvVXBwZXJDYXNlKCksZS5lbmNvZGUodCtuKSksWy4uLm5ldyBVaW50OEFycmF5KGwpXS5tYXAoZT0+ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwiMCIpKS5qb2luKCIiKX1mdW5jdGlvbiBuKGUsdD0xMil7bGV0IG49bmV3IFVpbnQ4QXJyYXkodCk7Zm9yKGxldCByPTA7cjx0O3IrKyluW3JdPWUlMjU2LGU9TWF0aC5mbG9vcihlLzI1Nik7cmV0dXJuIG59YXN5bmMgZnVuY3Rpb24gcih0LHI9IiIsbD0xZTYsbz0wKXtsZXQgYT0iQUVTLUdDTSIsYz1uZXcgQWJvcnRDb250cm9sbGVyLGk9RGF0ZS5ub3coKSx1PShhc3luYygpPT57Zm9yKGxldCBlPW87ZTw9bCYmIWMuc2lnbmFsLmFib3J0ZWQmJnMmJnc7ZSsrKXRyeXtsZXQgdD1hd2FpdCBjcnlwdG8uc3VidGxlLmRlY3J5cHQoe25hbWU6YSxpdjpuKGUpfSxzLHcpO2lmKHQpcmV0dXJue2NsZWFyVGV4dDpuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodCksdG9vazpEYXRlLm5vdygpLWl9fWNhdGNoe31yZXR1cm4gbnVsbH0pKCkscz1udWxsLHc9bnVsbDt0cnl7dz1mdW5jdGlvbiBlKHQpe2xldCBuPWF0b2IodCkscj1uZXcgVWludDhBcnJheShuLmxlbmd0aCk7Zm9yKGxldCBsPTA7bDxuLmxlbmd0aDtsKyspcltsXT1uLmNoYXJDb2RlQXQobCk7cmV0dXJuIHJ9KHQpO2xldCBmPWF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCJTSEEtMjU2IixlLmVuY29kZShyKSk7cz1hd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgicmF3IixmLGEsITEsWyJkZWNyeXB0Il0pfWNhdGNoe3JldHVybntwcm9taXNlOlByb21pc2UucmVqZWN0KCksY29udHJvbGxlcjpjfX1yZXR1cm57cHJvbWlzZTp1LGNvbnRyb2xsZXI6Y319bGV0IGw7b25tZXNzYWdlPWFzeW5jIGU9PntsZXR7dHlwZTpuLHBheWxvYWQ6byxzdGFydDphLG1heDpjfT1lLmRhdGEsaT1udWxsO2lmKCJhYm9ydCI9PT1uKWwmJmwuYWJvcnQoKSxsPXZvaWQgMDtlbHNlIGlmKCJ3b3JrIj09PW4pe2lmKCJvYmZ1c2NhdGVkImluIG8pe2xldHtrZXk6dSxvYmZ1c2NhdGVkOnN9PW98fHt9O2k9YXdhaXQgcihzLHUsYyxhKX1lbHNle2xldHthbGdvcml0aG06dyxjaGFsbGVuZ2U6ZixzYWx0OmR9PW98fHt9O2k9ZnVuY3Rpb24gZShuLHIsbD0iU0hBLTI1NiIsbz0xZTYsYT0wKXtsZXQgYz1uZXcgQWJvcnRDb250cm9sbGVyLGk9RGF0ZS5ub3coKSx1PShhc3luYygpPT57Zm9yKGxldCBlPWE7ZTw9byYmIWMuc2lnbmFsLmFib3J0ZWQ7ZSsrKXtsZXQgdT1hd2FpdCB0KHIsZSxsKTtpZih1PT09bilyZXR1cm57bnVtYmVyOmUsdG9vazpEYXRlLm5vdygpLWl9fXJldHVybiBudWxsfSkoKTtyZXR1cm57cHJvbWlzZTp1LGNvbnRyb2xsZXI6Y319KGYsZCx3LGMsYSl9bD1pLmNvbnRyb2xsZXIsaS5wcm9taXNlLnRoZW4oZT0+e3NlbGYucG9zdE1lc3NhZ2UoZSYmey4uLmUsd29ya2VyOiEwfSl9KX19fSgpOw==";
                this.workerBlob = Uint8Array.from(atob(this.workerBlob), e => e.charCodeAt(0));
                this.workJSBlob = new Blob([this.workerBlob], {
                    type: "text/javascript;charset=utf-8"
                });
            }
            async fetchServers() {
                let serverAPI = `${config.isSandbox ? "https://api-sandbox.moomoo.io" : "https://api.moomoo.io"}/servers?v=1.26`;
                let mode = config.isSandbox ? "sandbox" : "normal";
                let serverList = await (await fetch(serverAPI)).json();
                return { servers: await vultrClient.processServers(serverList), mode: mode };
            }

            createWorker(workerOptions) {
                let url = this.workJSBlob && this.selfFunc.createObjectURL(this.workJSBlob);
                let worker = new Worker(url, { name: workerOptions?.name });
                worker.addEventListener("error", () => {
                    this.selfFunc.revokeObjectURL(url);
                });

                return worker;
            }

            async getChallenge() {
                let response = await fetch("https://api.moomoo.io/verify", { headers: {} });
                let challengeData = await response.json();
                return challengeData;
            }

            async getWorkerSolution(taskData, totalWork, numWorkers = 8) {
                let workers = [];
                for (let i = 0; i < numWorkers; i++) {
                    workers.push(this.createWorker(undefined));
                }
                let chunkSize = ceil(totalWork / numWorkers);
                let results = await Promise.all(workers.map((worker, index) => {
                    let start = index * chunkSize;
                    return new Promise(resolve => {
                        worker.addEventListener("message", message => {
                            if (message.data) {
                                workers.forEach(w => {
                                    if (w !== worker) {
                                        w.postMessage({ type: "abort" });
                                    }
                                });
                            }
                            resolve(message.data);
                        });
                        worker.postMessage({
                            payload: taskData,
                            max: start + chunkSize,
                            start: start,
                            type: "work"
                        });
                    });
                }));
                workers.forEach(worker => worker.terminate());
                return results.find(result => !!result) || null;
            }

            async validateChallenge(challengeData) {
                let solution = await this.getWorkerSolution(challengeData, challengeData.maxnumber);
                if (solution?.number !== undefined || "obfuscated" in challengeData) {
                    return {
                        challengeData: challengeData,
                        solution: solution
                    };
                }
            }

            createPayload(payloadData, timingData) {
                return btoa(JSON.stringify({
                    algorithm: payloadData.algorithm,
                    challenge: payloadData.challenge,
                    number: timingData.number,
                    salt: payloadData.salt,
                    signature: payloadData.signature,
                    test: !!payloadData || undefined,
                    took: timingData.took
                }));
            }

            async executeRecaptcha() {
                try {
                    let challengeData = await this.getChallenge();
                    let { solution: solutionData } = await this.validateChallenge(challengeData);
                    this.altchaCode = `alt:${this.createPayload(challengeData, solutionData)}`;
                    return this.altchaCode;
                } catch (error) {
                    console.error("ALTCHA Token Generation", error);
                }
            }
        }
        var altchaManager = new AltchaManager();
        class GameObject {
            constructor(sid) {
                this.sid = sid;
                this.init = function (x, y, dir, scale, type, data, owner) {
                    data = data || {};
                    this.sentTo = {};
                    this.gridLocations = [];
                    this.active = true;
                    this.doUpdate = data.doUpdate;
                    this.shootReload = 2200 - (1000 / 9) * 2;
                    this.shootted = 0;
                    this.x = x;
                    this.y = y;
                    this.dir = dir;
                    this.xWiggle = 0;
                    this.yWiggle = 0;
                    this.scale = scale;
                    this.type = type;
                    this.id = data.id;
                    this.owner = owner;
                    this.name = data.name;
                    this.isItem = this.id !== undefined;
                    this.group = data.group;
                    this.health = data.health;
                    this.buildHealth = data.health;
                    this.layer = 2;
                    if (this.group !== undefined) {
                        this.layer = this.group.layer;
                    } else if (this.type === 0) {
                        this.layer = 3;
                    } else if (this.type === 2) {
                        this.layer = 0;
                    } else if (this.type === 4) {
                        this.layer = -1;
                    }
                    this.colDiv = data.colDiv || 1;
                    this.blocker = data.blocker;
                    this.ignoreCollision = data.ignoreCollision;
                    this.dontGather = data.dontGather;
                    this.hideFromEnemy = data.hideFromEnemy;
                    this.friction = data.friction;
                    this.projDmg = data.projDmg;
                    this.dmg = data.dmg;
                    this.pDmg = data.pDmg;
                    this.pps = data.pps;
                    this.zIndex = data.zIndex || 0;
                    this.turnSpeed = data.turnSpeed;
                    this.req = data.req;
                    this.trap = data.trap;
                    this.healCol = data.healCol;
                    this.teleport = data.teleport;
                    this.boostSpeed = data.boostSpeed;
                    this.projectile = data.projectile;
                    this.shootRange = data.shootRange;
                    this.shootRate = data.shootRate;
                    this.shootCount = this.shootRate;
                    this.spawnPoint = data.spawnPoint;
                };
                this.changeHealth = function (amount, doer) {
                    this.health += amount;
                    return this.health <= 0;
                };
                this.getScale = function (sM, ig) {
                    sM = sM || 1;
                    return (
                        this.scale *
                        (this.isItem || this.type === 2 || this.type === 3 || this.type === 4
                         ? 1
                         : 0.6 * sM) *
                        (ig ? 1 : this.colDiv)
                    );
                };
                this.visibleToPlayer = function (player) {
                    return !this.hideFromEnemy || (
                        this.owner &&
                        (this.owner === player ||
                         (this.owner.team && player.team === this.owner.team))
                    );
                };
                this.update = function (delta) {
                    if (this.active) {
                        if (this.xWiggle) {
                            this.xWiggle *= pow(0.99, delta);
                        }
                        if (this.yWiggle) {
                            this.yWiggle *= pow(0.99, delta);
                        }
                        this.dir += this.turnSpeed * delta;
                    }
                };
            }
        };
        class Items {
            constructor() {
                // ITEM GROUPS:
                this.groups = [{
                    id: 0,
                    name: "food",
                    layer: 0
                }, {
                    id: 1,
                    name: "walls",
                    place: true,
                    limit: 30,
                    layer: 0
                }, {
                    id: 2,
                    name: "spikes",
                    place: true,
                    limit: 15,
                    layer: 0
                }, {
                    id: 3,
                    name: "mill",
                    place: true,
                    limit: 7,
                    layer: 1
                }, {
                    id: 4,
                    name: "mine",
                    place: true,
                    limit: 1,
                    layer: 0
                }, {
                    id: 5,
                    name: "trap",
                    place: true,
                    limit: 6,
                    layer: -1
                }, {
                    id: 6,
                    name: "booster",
                    place: true,
                    limit: 12,
                    layer: -1
                }, {
                    id: 7,
                    name: "turret",
                    place: true,
                    limit: 2,
                    layer: 1
                }, {
                    id: 8,
                    name: "watchtower",
                    place: true,
                    limit: 12,
                    layer: 1
                }, {
                    id: 9,
                    name: "buff",
                    place: true,
                    limit: 4,
                    layer: -1
                }, {
                    id: 10,
                    name: "spawn",
                    place: true,
                    limit: 1,
                    layer: -1
                }, {
                    id: 11,
                    name: "sapling",
                    place: true,
                    limit: 2,
                    layer: 0
                }, {
                    id: 12,
                    name: "blocker",
                    place: true,
                    limit: 3,
                    layer: -1
                }, {
                    id: 13,
                    name: "teleporter",
                    place: true,
                    limit: 2,
                    layer: -1
                }];

                // PROJECTILES:
                this.projectiles = [{
                    indx: 0,
                    layer: 0,
                    src: "arrow_1",
                    dmg: 25,
                    speed: 1.6,
                    scale: 103,
                    range: 1000
                }, {
                    indx: 1,
                    layer: 1,
                    dmg: 25,
                    scale: 20
                }, {
                    indx: 0,
                    layer: 0,
                    src: "arrow_1",
                    dmg: 35,
                    speed: 2.5,
                    scale: 103,
                    range: 1200
                }, {
                    indx: 0,
                    layer: 0,
                    src: "arrow_1",
                    dmg: 30,
                    speed: 2,
                    scale: 103,
                    range: 1200
                }, {
                    indx: 1,
                    layer: 1,
                    dmg: 16,
                    scale: 20
                }, {
                    indx: 0,
                    layer: 0,
                    src: "bullet_1",
                    dmg: 50,
                    speed: 3.6,
                    scale: 160,
                    range: 1400
                }];

                // WEAPONS:
                this.weapons = [{
                    id: 0,
                    type: 0,
                    name: "tool hammer",
                    desc: "tool for gathering all resources",
                    src: "hammer_1",
                    length: 140,
                    width: 140,
                    xOff: -3,
                    yOff: 18,
                    dmg: 25,
                    range: 65,
                    gather: 1,
                    speed: 300
                }, {
                    id: 1,
                    type: 0,
                    age: 2,
                    name: "hand axe",
                    desc: "gathers resources at a higher rate",
                    src: "axe_1",
                    length: 140,
                    width: 140,
                    xOff: 3,
                    yOff: 24,
                    dmg: 30,
                    spdMult: 1,
                    range: 70,
                    gather: 2,
                    speed: 400
                }, {
                    id: 2,
                    type: 0,
                    age: 8,
                    pre: 1,
                    name: "great axe",
                    desc: "deal more damage and gather more resources",
                    src: "great_axe_1",
                    length: 140,
                    width: 140,
                    xOff: -8,
                    yOff: 25,
                    dmg: 35,
                    spdMult: 1,
                    range: 75,
                    gather: 4,
                    speed: 400
                }, {
                    id: 3,
                    type: 0,
                    age: 2,
                    name: "short sword",
                    desc: "increased attack power but slower move speed",
                    src: "sword_1",
                    iPad: 1.3,
                    length: 130,
                    width: 210,
                    xOff: -8,
                    yOff: 46,
                    dmg: 35,
                    spdMult: 0.85,
                    range: 110,
                    gather: 1,
                    speed: 300
                }, {
                    id: 4,
                    type: 0,
                    age: 8,
                    pre: 3,
                    name: "katana",
                    desc: "greater range and damage",
                    src: "samurai_1",
                    iPad: 1.3,
                    length: 130,
                    width: 210,
                    xOff: -8,
                    yOff: 59,
                    dmg: 40,
                    spdMult: 0.8,
                    range: 118,
                    gather: 1,
                    speed: 300
                }, {
                    id: 5,
                    type: 0,
                    age: 2,
                    name: "polearm",
                    desc: "long range melee weapon",
                    src: "spear_1",
                    iPad: 1.3,
                    length: 130,
                    width: 210,
                    xOff: -8,
                    yOff: 53,
                    dmg: 45,
                    knock: 0.2,
                    spdMult: 0.82,
                    range: 142,
                    gather: 1,
                    speed: 700
                }, {
                    id: 6,
                    type: 0,
                    age: 2,
                    name: "bat",
                    desc: "fast long range melee weapon",
                    src: "bat_1",
                    iPad: 1.3,
                    length: 110,
                    width: 180,
                    xOff: -8,
                    yOff: 53,
                    dmg: 20,
                    knock: 0.7,
                    range: 110,
                    gather: 1,
                    speed: 300
                }, {
                    id: 7,
                    type: 0,
                    age: 2,
                    name: "daggers",
                    desc: "really fast short range weapon",
                    src: "dagger_1",
                    iPad: 0.8,
                    length: 110,
                    width: 110,
                    xOff: 18,
                    yOff: 0,
                    dmg: 20,
                    knock: 0.1,
                    range: 65,
                    gather: 1,
                    hitSlow: 0.1,
                    spdMult: 1.13,
                    speed: 100
                }, {
                    id: 8,
                    type: 0,
                    age: 2,
                    name: "stick",
                    desc: "great for gathering but very weak",
                    src: "stick_1",
                    length: 140,
                    width: 140,
                    xOff: 3,
                    yOff: 24,
                    dmg: 1,
                    spdMult: 1,
                    range: 70,
                    gather: 7,
                    speed: 400
                }, {
                    id: 9,
                    type: 1,
                    age: 6,
                    name: "hunting bow",
                    desc: "bow used for ranged combat and hunting",
                    src: "bow_1",
                    req: ["wood", 4],
                    length: 120,
                    width: 120,
                    xOff: -6,
                    yOff: 0,
                    Pdmg: 25,
                    projectile: 0,
                    spdMult: 0.75,
                    speed: 600
                }, {
                    id: 10,
                    type: 1,
                    age: 6,
                    name: "great hammer",
                    desc: "hammer used for destroying structures",
                    src: "great_hammer_1",
                    length: 140,
                    width: 140,
                    xOff: -9,
                    yOff: 25,
                    dmg: 10,
                    Pdmg: 10,
                    spdMult: 0.88,
                    range: 75,
                    sDmg: 7.5,
                    gather: 1,
                    speed: 400
                }, {
                    id: 11,
                    type: 1,
                    age: 6,
                    name: "wooden shield",
                    desc: "blocks projectiles and reduces melee damage",
                    src: "shield_1",
                    length: 120,
                    width: 120,
                    shield: 0.2,
                    xOff: 6,
                    yOff: 0,
                    Pdmg: 0,
                    spdMult: 0.7
                }, {
                    id: 12,
                    type: 1,
                    age: 8,
                    pre: 9,
                    name: "crossbow",
                    desc: "deals more damage and has greater range",
                    src: "crossbow_1",
                    req: ["wood", 5],
                    aboveHand: true,
                    armS: 0.75,
                    length: 120,
                    width: 120,
                    xOff: -4,
                    yOff: 0,
                    Pdmg: 35,
                    projectile: 2,
                    spdMult: 0.7,
                    speed: 700
                }, {
                    id: 13,
                    type: 1,
                    age: 9,
                    pre: 12,
                    name: "repeater crossbow",
                    desc: "high firerate crossbow with reduced damage",
                    src: "crossbow_2",
                    req: ["wood", 10],
                    aboveHand: true,
                    armS: 0.75,
                    length: 120,
                    width: 120,
                    xOff: -4,
                    yOff: 0,
                    Pdmg: 30,
                    projectile: 3,
                    spdMult: 0.7,
                    speed: 230
                }, {
                    id: 14,
                    type: 1,
                    age: 6,
                    name: "mc grabby",
                    desc: "steals resources from enemies",
                    src: "grab_1",
                    length: 130,
                    width: 210,
                    xOff: -8,
                    yOff: 53,
                    dmg: 0,
                    Pdmg: 0,
                    steal: 250,
                    knock: 0.2,
                    spdMult: 1.05,
                    range: 125,
                    gather: 0,
                    speed: 700
                }, {
                    id: 15,
                    type: 1,
                    age: 9,
                    pre: 12,
                    name: "musket",
                    desc: "slow firerate but high damage and range",
                    src: "musket_1",
                    req: ["stone", 10],
                    aboveHand: true,
                    rec: 0.35,
                    armS: 0.6,
                    hndS: 0.3,
                    hndD: 1.6,
                    length: 205,
                    width: 205,
                    xOff: 25,
                    yOff: 0,
                    Pdmg: 50,
                    projectile: 5,
                    hideProjectile: true,
                    spdMult: 0.6,
                    speed: 1500
                }];

                // ITEMS:
                this.list = [{
                    group: this.groups[0],
                    name: "apple",
                    desc: "restores 20 health when consumed",
                    req: ["food", 10],
                    consume: function (doer) {
                        return doer.changeHealth(20, doer);
                    },
                    scale: 22,
                    holdOffset: 15,
                    healing: 20,
                    itemID: 0,
                    itemAID: 16,
                }, {
                    age: 3,
                    group: this.groups[0],
                    name: "cookie",
                    desc: "restores 40 health when consumed",
                    req: ["food", 15],
                    consume: function (doer) {
                        return doer.changeHealth(40, doer);
                    },
                    scale: 27,
                    holdOffset: 15,
                    healing: 40,
                    itemID: 1,
                    itemAID: 17,
                }, {
                    age: 7,
                    group: this.groups[0],
                    name: "cheese",
                    desc: "restores 30 health and another 50 over 5 seconds",
                    req: ["food", 25],
                    consume: function (doer) {
                        if (doer.changeHealth(30, doer) || doer.health < 100) {
                            doer.dmgOverTime.dmg = -10;
                            doer.dmgOverTime.doer = doer;
                            doer.dmgOverTime.time = 5;
                            return true;
                        }
                        return false;
                    },
                    scale: 27,
                    holdOffset: 15,
                    healing: 30,
                    itemID: 2,
                    itemAID: 18,
                }, {
                    group: this.groups[1],
                    name: "wood wall",
                    desc: "provides protection for your village",
                    req: ["wood", 10],
                    projDmg: true,
                    health: 380,
                    scale: 50,
                    holdOffset: 20,
                    placeOffset: -5,
                    itemID: 3,
                    itemAID: 19,
                }, {
                    age: 3,
                    group: this.groups[1],
                    name: "stone wall",
                    desc: "provides improved protection for your village",
                    req: ["stone", 25],
                    health: 900,
                    scale: 50,
                    holdOffset: 20,
                    placeOffset: -5,
                    itemID: 4,
                    itemAID: 20,
                }, {
                    age: 7,
                    group: this.groups[1],
                    name: "castle wall",
                    desc: "provides powerful protection for your village",
                    req: ["stone", 35],
                    health: 1500,
                    scale: 52,
                    holdOffset: 20,
                    placeOffset: -5,
                    itemID: 5,
                    itemAID: 21,
                }, {
                    group: this.groups[2],
                    name: "spikes",
                    desc: "damages enemies when they touch them",
                    req: ["wood", 20, "stone", 5],
                    health: 400,
                    dmg: 20,
                    scale: 49,
                    spritePadding: -23,
                    holdOffset: 8,
                    placeOffset: -5,
                    itemID: 6,
                    itemAID: 22,
                }, {
                    age: 5,
                    group: this.groups[2],
                    name: "greater spikes",
                    desc: "damages enemies when they touch them",
                    req: ["wood", 30, "stone", 10],
                    health: 500,
                    dmg: 35,
                    scale: 52,
                    spritePadding: -23,
                    holdOffset: 8,
                    placeOffset: -5,
                    itemID: 7,
                    itemAID: 23,
                }, {
                    age: 9,
                    group: this.groups[2],
                    name: "poison spikes",
                    desc: "poisons enemies when they touch them",
                    req: ["wood", 35, "stone", 15],
                    health: 600,
                    dmg: 30,
                    pDmg: 5,
                    scale: 52,
                    spritePadding: -23,
                    holdOffset: 8,
                    placeOffset: -5,
                    itemID: 8,
                    itemAID: 24,
                }, {
                    age: 9,
                    group: this.groups[2],
                    name: "spinning spikes",
                    desc: "damages enemies when they touch them",
                    req: ["wood", 30, "stone", 20],
                    health: 500,
                    dmg: 45,
                    turnSpeed: 0.003,
                    scale: 52,
                    spritePadding: -23,
                    holdOffset: 8,
                    placeOffset: -5,
                    itemID: 9,
                    itemAID: 25,
                }, {
                    group: this.groups[3],
                    name: "windmill",
                    desc: "generates gold over time",
                    req: ["wood", 50, "stone", 10],
                    health: 400,
                    pps: 1,
                    turnSpeed: 0.0016,
                    spritePadding: 25,
                    iconLineMult: 12,
                    scale: 45,
                    holdOffset: 20,
                    placeOffset: 5,
                    itemID: 10,
                    itemAID: 26,
                }, {
                    age: 5,
                    group: this.groups[3],
                    name: "faster windmill",
                    desc: "generates more gold over time",
                    req: ["wood", 60, "stone", 20],
                    health: 500,
                    pps: 1.5,
                    turnSpeed: 0.0025,
                    spritePadding: 25,
                    iconLineMult: 12,
                    scale: 47,
                    holdOffset: 20,
                    placeOffset: 5,
                    itemID: 11,
                    itemAID: 27,
                }, {
                    age: 8,
                    group: this.groups[3],
                    name: "power mill",
                    desc: "generates more gold over time",
                    req: ["wood", 100, "stone", 50],
                    health: 800,
                    pps: 2,
                    turnSpeed: 0.005,
                    spritePadding: 25,
                    iconLineMult: 12,
                    scale: 47,
                    holdOffset: 20,
                    placeOffset: 5,
                    itemID: 12,
                    itemAID: 28,
                }, {
                    age: 5,
                    group: this.groups[4],
                    type: 2,
                    name: "mine",
                    desc: "allows you to mine stone",
                    req: ["wood", 20, "stone", 100],
                    iconLineMult: 12,
                    scale: 65,
                    holdOffset: 20,
                    placeOffset: 0,
                    itemID: 13,
                    itemAID: 29,
                }, {
                    age: 5,
                    group: this.groups[11],
                    type: 0,
                    name: "sapling",
                    desc: "allows you to farm wood",
                    req: ["wood", 150],
                    iconLineMult: 12,
                    colDiv: 0.5,
                    scale: 110,
                    holdOffset: 50,
                    placeOffset: -15,
                    itemID: 14,
                    itemAID: 30,
                }, {
                    age: 4,
                    group: this.groups[5],
                    name: "pit trap",
                    desc: "pit that traps enemies if they walk over it",
                    req: ["wood", 30, "stone", 30],
                    trap: true,
                    ignoreCollision: true,
                    hideFromEnemy: true,
                    health: 500,
                    colDiv: 0.2,
                    scale: 50,
                    holdOffset: 20,
                    placeOffset: -5,
                    alpha: 0.6,
                    itemID: 15,
                    itemAID: 31,
                }, {
                    age: 4,
                    group: this.groups[6],
                    name: "boost pad",
                    desc: "provides boost when stepped on",
                    req: ["stone", 20, "wood", 5],
                    ignoreCollision: true,
                    boostSpeed: 1.5,
                    health: 150,
                    colDiv: 0.7,
                    scale: 45,
                    holdOffset: 20,
                    placeOffset: -5,
                    itemID: 16,
                    itemAID: 32,
                }, {
                    age: 7,
                    group: this.groups[7],
                    doUpdate: true,
                    name: "turret",
                    desc: "defensive structure that shoots at enemies",
                    req: ["wood", 200, "stone", 150],
                    health: 800,
                    projectile: 1,
                    shootRange: 700,
                    shootRate: 2200,
                    scale: 43,
                    holdOffset: 20,
                    placeOffset: -5,
                    itemID: 17,
                    itemAID: 33,
                }, {
                    age: 7,
                    group: this.groups[8],
                    name: "platform",
                    desc: "platform to shoot over walls and cross over water",
                    req: ["wood", 20],
                    ignoreCollision: true,
                    zIndex: 1,
                    health: 300,
                    scale: 43,
                    holdOffset: 20,
                    placeOffset: -5,
                    itemID: 18,
                    itemAID: 34,
                }, {
                    age: 7,
                    group: this.groups[9],
                    name: "healing pad",
                    desc: "standing on it will slowly heal you",
                    req: ["wood", 30, "food", 10],
                    ignoreCollision: true,
                    healCol: 15,
                    health: 400,
                    colDiv: 0.7,
                    scale: 45,
                    holdOffset: 20,
                    placeOffset: -5,
                    itemID: 19,
                    itemAID: 35,
                }, {
                    age: 9,
                    group: this.groups[10],
                    name: "spawn pad",
                    desc: "you will spawn here when you die but it will dissapear",
                    req: ["wood", 100, "stone", 100],
                    health: 400,
                    ignoreCollision: true,
                    spawnPoint: true,
                    scale: 45,
                    holdOffset: 20,
                    placeOffset: -5,
                    itemID: 20,
                    itemAID: 36,
                }, {
                    age: 7,
                    group: this.groups[12],
                    name: "blocker",
                    desc: "blocks building in radius",
                    req: ["wood", 30, "stone", 25],
                    ignoreCollision: true,
                    blocker: 300,
                    health: 400,
                    colDiv: 0.7,
                    scale: 45,
                    holdOffset: 20,
                    placeOffset: -5,
                    itemID: 21,
                    itemAID: 37,
                }, {
                    age: 7,
                    group: this.groups[13],
                    name: "teleporter",
                    desc: "teleports you to a random point on the map",
                    req: ["wood", 60, "stone", 60],
                    ignoreCollision: true,
                    teleport: true,
                    health: 200,
                    colDiv: 0.7,
                    scale: 45,
                    holdOffset: 20,
                    placeOffset: -5,
                    itemID: 22,
                    itemAID: 38
                }];

                // CHECK ITEM ID:
                this.checkItem = {
                    index: function(id, myItems) {
                        return [0, 1, 2].includes(id) ? 0 :
                        [3, 4, 5].includes(id) ? 1 :
                        [6, 7, 8, 9].includes(id) ? 2 :
                        [10, 11, 12].includes(id) ? 3 :
                        [13, 14].includes(id) ? 5 :
                        [15, 16].includes(id) ? 4 :
                        [17, 18, 19, 21, 22].includes(id) ?
                            [13, 14].includes(myItems) ? 6 :
                        5 :
                        id == 20 ?
                            [13, 14].includes(myItems) ? 7 :
                        6 :
                        undefined;
                    }
                }
                for (let i = 0; i < this.list.length; ++i) {
                    this.list[i].id = i;
                    if (this.list[i].pre) this.list[i].pre = i - this.list[i].pre;
                }
            }
        }
        let items = new Items();
        class Projectile {
            constructor(players, ais, objectManager, items, config, Utils, server) {
                // INIT:
                this.init = function(indx, x, y, dir, spd, dmg, rng, scl, owner) {
                    this.active = true;
                    this.indx = indx;
                    this.x = x;
                    this.y = y;
                    this.dir = dir;
                    this.skipMov = true;
                    this.speed = spd;
                    this.dmg = dmg;
                    this.scale = scl;
                    this.range = rng;
                    this.owner = owner;
                    this.sentTo = {};
                };
                // UPDATE:
                var objectsHit = [];
                var tmpObj;
                this.update = function(delta) {
                    if (this.active) {
                        var tmpSpeed = this.speed * delta;
                        var tmpScale;
                        if (!this.skipMov) {
                            this.x += tmpSpeed * cos(this.dir);
                            this.y += tmpSpeed * sin(this.dir);
                            this.range -= tmpSpeed;
                            if (this.range <= 0) {
                                this.x += this.range * cos(this.dir);
                                this.y += this.range * sin(this.dir);
                                tmpSpeed = 1;
                                this.range = 0;
                                this.active = false;
                            }
                        } else {
                            this.skipMov = false;
                        }
                        if (server) {
                            for (let i = 0; i < players.length; ++i) {
                                if (!this.sentTo[players[i].id] && players[i].canSee(this)) {
                                    this.sentTo[players[i].id] = 1;
                                    server.send(players[i].id, "X", Utils.fixTo(this.x, 1), Utils.fixTo(this.y, 1), Utils.fixTo(this.dir, 2), Utils.fixTo(this.range, 1), this.speed, this.indx, this.layer, this.sid);
                                }
                            }
                            objectsHit.length = 0;
                            for (let i = 0; i < players.length + ais.length; ++i) {
                                tmpObj = players[i] || ais[i - players.length];
                                if (tmpObj.alive && tmpObj != this.owner && !(this.owner.team && tmpObj.team == this.owner.team)) {
                                    if (Utils.lineInRect(tmpObj.x - tmpObj.scale, tmpObj.y - tmpObj.scale, tmpObj.x + tmpObj.scale, tmpObj.y + tmpObj.scale, this.x, this.y, this.x + tmpSpeed * cos(this.dir), this.y + tmpSpeed * sin(this.dir))) {
                                        objectsHit.push(tmpObj);
                                    }
                                }
                            }
                            var tmpList = objectManager.getGridArrays(this.x, this.y, this.scale);
                            for (var x = 0; x < tmpList.length; ++x) {
                                for (var y = 0; y < tmpList[x].length; ++y) {
                                    tmpObj = tmpList[x][y];
                                    tmpScale = tmpObj.getScale();
                                    if (tmpObj.active && !(this.ignoreObj == tmpObj.sid) && this.layer <= tmpObj.layer && objectsHit.indexOf(tmpObj) < 0 && !tmpObj.ignoreCollision && Utils.lineInRect(tmpObj.x - tmpScale, tmpObj.y - tmpScale, tmpObj.x + tmpScale, tmpObj.y + tmpScale, this.x, this.y, this.x + tmpSpeed * cos(this.dir), this.y + tmpSpeed * sin(this.dir))) {
                                        objectsHit.push(tmpObj);
                                    }
                                }
                            }
                            // HIT OBJECTS:
                            if (objectsHit.length > 0) {
                                var hitObj = null;
                                var shortDist = null;
                                var tmpDist = null;
                                for (let i = 0; i < objectsHit.length; ++i) {
                                    tmpDist = Utils.getDistance(this.x, this.y, objectsHit[i].x, objectsHit[i].y);
                                    if (shortDist == null || tmpDist < shortDist) {
                                        shortDist = tmpDist;
                                        hitObj = objectsHit[i];
                                    }
                                }
                                if (hitObj.isPlayer || hitObj.isAI) {
                                    var tmpSd = 0.3 * (hitObj.weightM || 1);
                                    hitObj.xVel += tmpSd * cos(this.dir);
                                    hitObj.yVel += tmpSd * sin(this.dir);
                                    if (hitObj.weaponIndex == undefined || !(items.weapons[hitObj.weaponIndex].shield && Utils.getAngleDist(this.dir + pi, hitObj.dir) <= config.shieldAngle)) {
                                        hitObj.changeHealth(-this.dmg, this.owner, this.owner);
                                    }
                                } else {
                                    if (hitObj.projDmg && hitObj.health && hitObj.changeHealth(-this.dmg)) {
                                        objectManager.disableObj(hitObj);
                                    }
                                    for (let i = 0; i < players.length; ++i) {
                                        if (players[i].active) {
                                            if (hitObj.sentTo[players[i].id]) {
                                                if (hitObj.active) {
                                                    if (players[i].canSee(hitObj)) {
                                                        server.send(players[i].id, "L", Utils.fixTo(this.dir, 2), hitObj.sid);
                                                    }
                                                } else {
                                                    server.send(players[i].id, "Q", hitObj.sid);
                                                }
                                            }
                                            if (!hitObj.active && hitObj.owner == players[i]) {
                                                players[i].changeItemCount(hitObj.group.id, -1);
                                            }
                                        }
                                    }
                                }
                                this.active = false;
                                for (let i = 0; i < players.length; ++i) {
                                    if (this.sentTo[players[i].id]) {
                                        server.send(players[i].id, "Y", this.sid, Utils.fixTo(shortDist, 1));
                                    }
                                }
                            }
                        }
                    }
                };
            };
        }
        class ObjectManager {
            constructor(GameObject, gameObjects, Utils, config, players, server) {
                this.objects = gameObjects;
                this.grids = {};
                this.updateObjects = [];
                this.GameObject = GameObject;
                this.Utils = Utils;
                this.config = config;
                this.players = players;
                this.server = server;
                this.tmpArray = [];
            }

            setObjectGrids(obj) {
                var tmpX, tmpY;
                var tmpS = this.config.mapScale / this.config.colGrid;
                var objX = min(this.config.mapScale, max(0, obj.x));
                var objY = min(this.config.mapScale, max(0, obj.y));

                for (var x = 0; x < this.config.colGrid; ++x) {
                    tmpX = x * tmpS;
                    for (var y = 0; y < this.config.colGrid; ++y) {
                        tmpY = y * tmpS;
                        if (objX + obj.scale >= tmpX && objX - obj.scale <= tmpX + tmpS &&
                            objY + obj.scale >= tmpY && objY - obj.scale <= tmpY + tmpS) {
                            if (!this.grids[x + "_" + y]) {
                                this.grids[x + "_" + y] = [];
                            }
                            this.grids[x + "_" + y].push(obj);
                            obj.gridLocations.push(x + "_" + y);
                        }
                    }
                }
            }

            removeObjGrid(obj) {
                var tmpIndx;
                for (let i = 0; i < obj.gridLocations.length; ++i) {
                    tmpIndx = this.grids[obj.gridLocations[i]].indexOf(obj);
                    if (tmpIndx >= 0) {
                        this.grids[obj.gridLocations[i]].splice(tmpIndx, 1);
                    }
                }
            }

            disableObj(obj) {
                obj.active = false;
                if (this.server) {
                    if (obj.owner && obj.pps) {
                        obj.owner.pps -= obj.pps;
                    }
                    this.removeObjGrid(obj);
                    var tmpIndx = this.updateObjects.indexOf(obj);
                    if (tmpIndx >= 0) {
                        this.updateObjects.splice(tmpIndx, 1);
                    }
                }
            }

            hitObj(tmpObj, tmpDir) {
                for (var p = 0; p < this.players.length; ++p) {
                    if (this.players[p].active) {
                        if (tmpObj.sentTo[this.players[p].id]) {
                            if (!tmpObj.active) {
                                this.server.send(this.players[p].id, "Q", tmpObj.sid);
                            } else if (this.players[p].canSee(tmpObj)) {
                                this.server.send(this.players[p].id, "L", this.Utils.fixTo(tmpDir, 1), tmpObj.sid);
                            }
                        }
                        if (!tmpObj.active && tmpObj.owner == this.players[p]) {
                            this.players[p].changeItemCount(tmpObj.group.id, -1);
                        }
                    }
                }
            }

            getGridArrays(xPos, yPos, s) {
                var tmpX = floor(xPos / (this.config.mapScale / this.config.colGrid));
                var tmpY = floor(yPos / (this.config.mapScale / this.config.colGrid));
                var tmpS = this.config.mapScale / this.config.colGrid;

                this.tmpArray.length = 0;
                try {
                    if (this.grids[tmpX + "_" + tmpY]) {
                        this.tmpArray.push(this.grids[tmpX + "_" + tmpY]);
                    }
                    this.checkAdjacentGrids(tmpX, tmpY, xPos, yPos, s, tmpS);
                } catch (e) { }
                return this.tmpArray;
            }

            checkAdjacentGrids(tmpX, tmpY, xPos, yPos, s, tmpS) {
                var tmpGrid;
                if (xPos + s >= (tmpX + 1) * tmpS) {
                    tmpGrid = this.grids[tmpX + 1 + "_" + tmpY];
                    if (tmpGrid) this.tmpArray.push(tmpGrid);

                    if (tmpY && yPos - s <= tmpY * tmpS) {
                        tmpGrid = this.grids[tmpX + 1 + "_" + (tmpY - 1)];
                        if (tmpGrid) this.tmpArray.push(tmpGrid);
                    } else if (yPos + s >= (tmpY + 1) * tmpS) {
                        tmpGrid = this.grids[tmpX + 1 + "_" + (tmpY + 1)];
                        if (tmpGrid) this.tmpArray.push(tmpGrid);
                    }
                }

                if (tmpX && xPos - s <= tmpX * tmpS) {
                    tmpGrid = this.grids[tmpX - 1 + "_" + tmpY];
                    if (tmpGrid) this.tmpArray.push(tmpGrid);

                    if (tmpY && yPos - s <= tmpY * tmpS) {
                        tmpGrid = this.grids[tmpX - 1 + "_" + (tmpY - 1)];
                        if (tmpGrid) this.tmpArray.push(tmpGrid);
                    } else if (yPos + s >= (tmpY + 1) * tmpS) {
                        tmpGrid = this.grids[tmpX - 1 + "_" + (tmpY + 1)];
                        if (tmpGrid) this.tmpArray.push(tmpGrid);
                    }
                }

                if (yPos + s >= (tmpY + 1) * tmpS) {
                    tmpGrid = this.grids[tmpX + "_" + (tmpY + 1)];
                    if (tmpGrid) this.tmpArray.push(tmpGrid);
                }
                if (tmpY && yPos - s <= tmpY * tmpS) {
                    tmpGrid = this.grids[tmpX + "_" + (tmpY - 1)];
                    if (tmpGrid) this.tmpArray.push(tmpGrid);
                }
            }

            add(sid, x, y, dir, s, type, data, setSID, owner) {
                var tmpObj = this.objects.find((tmp) => tmp.sid == sid);
                if (!tmpObj) {
                    tmpObj = this.objects.find((tmp) => !tmp.active);
                    if (!tmpObj) {
                        tmpObj = new this.GameObject(sid);
                        this.objects.push(tmpObj);
                    }
                }
                if (setSID) tmpObj.sid = sid;
                tmpObj.init(x, y, dir, s, type, data, owner);

                if (this.server) {
                    this.setObjectGrids(tmpObj);
                    if (tmpObj.doUpdate) this.updateObjects.push(tmpObj);
                }
            }

            disableBySid(sid) {
                var find = this.objects.find((tmp) => tmp.sid == sid);
                if (find) {
                    this.disableObj(find);
                }
            }

            removeAllItems(sid, server) {
                this.objects.filter((tmp) => tmp.active && tmp.owner && tmp.owner.sid == sid)
                    .forEach((tmp) => this.disableObj(tmp));
                if (server) {
                    server.broadcast("R", sid);
                }
            }

            fetchSpawnObj(sid) {
                var tmpLoc = null;
                for (let i = 0; i < this.objects.length; ++i) {
                    var tmpObj = this.objects[i];
                    if (tmpObj.active && tmpObj.owner && tmpObj.owner.sid == sid && tmpObj.spawnPoint) {
                        tmpLoc = [tmpObj.x, tmpObj.y];
                        this.disableObj(tmpObj);
                        this.server.broadcast("Q", tmpObj.sid);
                        if (tmpObj.owner) {
                            tmpObj.owner.changeItemCount(tmpObj.group.id, -1);
                        }
                        break;
                    }
                }
                return tmpLoc;
            }

            checkItemLocation(x, y, s, sM, indx, ignoreWater, placer) {
                var cantPlace = this.objects.find((tmp) =>
                                                  tmp.active && this.Utils.getDistance(x, y, tmp.x, tmp.y) <
                                                  s + (tmp.blocker ? tmp.blocker : tmp.getScale(sM, tmp.isItem))
                                                 );
                if (cantPlace) {
                    return false;
                }
                if (!ignoreWater && indx != 18 &&
                    y >= this.config.mapScale / 2 - this.config.riverWidth / 2 &&
                    y <= this.config.mapScale / 2 + this.config.riverWidth / 2) {
                    return false;
                }
                return true;
            }

            addProjectile(x, y, dir, range, indx) {
                var tmpData = items.projectiles[indx];
                var tmpProj = projectiles.find((tmp) => !tmp.active);
                if (!tmpProj) {
                    tmpProj = new Projectile(this.players, this.Utils);
                    projectiles.push(tmpProj);
                }
                tmpProj.init(indx, x, y, dir, tmpData.speed, range, tmpData.scale);
            }

            checkCollision(player, other, delta) {
                var dx = player.x - other.x;
                var dy = player.y - other.y;
                var tmpLen = player.scale + other.scale;

                if (abs(dx) <= tmpLen || abs(dy) <= tmpLen) {
                    tmpLen = player.scale + (other.getScale ? other.getScale() : other.scale);
                    var tmpInt = max(0, tmpLen - this.Utils.getDistance(0, 0, dx, dy));
                    if (tmpInt) {
                        var tmpAngle = atan2(dy, dx);
                        var tmpMove = min(tmpInt, delta);
                        player.x += cos(tmpAngle) * tmpMove;
                        player.y += sin(tmpAngle) * tmpMove;
                    }
                }
            }
        };
        class Store {
            constructor() {
                // STORE HATS:
                this.hats = [{
                    id: 45,
                    name: "Shame!",
                    dontSell: true,
                    price: 0,
                    scale: 120,
                    desc: "hacks are for winners"
                }, {
                    id: 51,
                    name: "Moo Cap",
                    price: 0,
                    scale: 120,
                    desc: "coolest mooer around"
                }, {
                    id: 50,
                    name: "Apple Cap",
                    price: 0,
                    scale: 120,
                    desc: "apple farms remembers"
                }, {
                    id: 28,
                    name: "Moo Head",
                    price: 0,
                    scale: 120,
                    desc: "no effect"
                }, {
                    id: 29,
                    name: "Pig Head",
                    price: 0,
                    scale: 120,
                    desc: "no effect"
                }, {
                    id: 30,
                    name: "Fluff Head",
                    price: 0,
                    scale: 120,
                    desc: "no effect"
                }, {
                    id: 36,
                    name: "Pandou Head",
                    price: 0,
                    scale: 120,
                    desc: "no effect"
                }, {
                    id: 37,
                    name: "Bear Head",
                    price: 0,
                    scale: 120,
                    desc: "no effect"
                }, {
                    id: 38,
                    name: "Monkey Head",
                    price: 0,
                    scale: 120,
                    desc: "no effect"
                }, {
                    id: 44,
                    name: "Polar Head",
                    price: 0,
                    scale: 120,
                    desc: "no effect"
                }, {
                    id: 35,
                    name: "Fez Hat",
                    price: 0,
                    scale: 120,
                    desc: "no effect"
                }, {
                    id: 42,
                    name: "Enigma Hat",
                    price: 0,
                    scale: 120,
                    desc: "join the enigma army"
                }, {
                    id: 43,
                    name: "Blitz Hat",
                    price: 0,
                    scale: 120,
                    desc: "hey everybody i'm blitz"
                }, {
                    id: 49,
                    name: "Bob XIII Hat",
                    price: 0,
                    scale: 120,
                    desc: "like and subscribe"
                }, {
                    id: 57,
                    name: "Pumpkin",
                    price: 50,
                    scale: 120,
                    desc: "Spooooky"
                }, {
                    id: 8,
                    name: "Bummle Hat",
                    price: 100,
                    scale: 120,
                    desc: "no effect"
                }, {
                    id: 2,
                    name: "Straw Hat",
                    price: 500,
                    scale: 120,
                    desc: "no effect"
                }, {
                    id: 15,
                    name: "Winter Cap",
                    price: 600,
                    scale: 120,
                    desc: "allows you to move at normal speed in snow",
                    coldM: 1
                }, {
                    id: 5,
                    name: "Cowboy Hat",
                    price: 1000,
                    scale: 120,
                    desc: "no effect"
                }, {
                    id: 4,
                    name: "Ranger Hat",
                    price: 2000,
                    scale: 120,
                    desc: "no effect"
                }, {
                    id: 18,
                    name: "Explorer Hat",
                    price: 2000,
                    scale: 120,
                    desc: "no effect"
                }, {
                    id: 31,
                    name: "Flipper Hat",
                    price: 2500,
                    scale: 120,
                    desc: "have more control while in water",
                    watrImm: true
                }, {
                    id: 1,
                    name: "Marksman Cap",
                    price: 3000,
                    scale: 120,
                    desc: "increases arrow speed and range",
                    aMlt: 1.3
                }, {
                    id: 10,
                    name: "Bush Gear",
                    price: 3000,
                    scale: 160,
                    desc: "allows you to disguise yourself as a bush"
                }, {
                    id: 48,
                    name: "Halo",
                    price: 3000,
                    scale: 120,
                    desc: "no effect"
                }, {
                    id: 6,
                    name: "Soldier Helmet",
                    price: 4000,
                    scale: 120,
                    desc: "reduces damage taken but slows movement",
                    spdMult: 0.94,
                    dmgMult: 0.75
                }, {
                    id: 23,
                    name: "Anti Venom Gear",
                    price: 4000,
                    scale: 120,
                    desc: "makes you immune to poison",
                    poisonRes: 1
                }, {
                    id: 13,
                    name: "Medic Gear",
                    price: 5000,
                    scale: 110,
                    desc: "slowly regenerates health over time",
                    healthRegen: 3
                }, {
                    id: 9,
                    name: "Miners Helmet",
                    price: 5000,
                    scale: 120,
                    desc: "earn 1 extra gold per resource",
                    extraGold: 1
                }, {
                    id: 32,
                    name: "Musketeer Hat",
                    price: 5000,
                    scale: 120,
                    desc: "reduces cost of projectiles",
                    projCost: 0.5
                }, {
                    id: 7,
                    name: "Bull Helmet",
                    price: 6000,
                    scale: 120,
                    desc: "increases damage done but drains health",
                    healthRegen: -5,
                    dmgMultO: 1.5,
                    spdMult: 0.96
                }, {
                    id: 22,
                    name: "Emp Helmet",
                    price: 6000,
                    scale: 120,
                    desc: "turrets won't attack but you move slower",
                    antiTurret: 1,
                    spdMult: 0.7
                }, {
                    id: 12,
                    name: "Booster Hat",
                    price: 6000,
                    scale: 120,
                    desc: "increases your movement speed",
                    spdMult: 1.16
                }, {
                    id: 26,
                    name: "Barbarian Armor",
                    price: 8000,
                    scale: 120,
                    desc: "knocks back enemies that attack you",
                    dmgK: 0.6
                }, {
                    id: 21,
                    name: "Plague Mask",
                    price: 10000,
                    scale: 120,
                    desc: "melee attacks deal poison damage",
                    poisonDmg: 5,
                    poisonTime: 6
                }, {
                    id: 46,
                    name: "Bull Mask",
                    price: 10000,
                    scale: 120,
                    desc: "bulls won't target you unless you attack them",
                    bullRepel: 1
                }, {
                    id: 14,
                    name: "Windmill Hat",
                    topSprite: true,
                    price: 10000,
                    scale: 120,
                    desc: "generates points while worn",
                    pps: 1.5
                }, {
                    id: 11,
                    name: "Spike Gear",
                    topSprite: true,
                    price: 10000,
                    scale: 120,
                    desc: "deal damage to players that damage you",
                    dmg: 0.45
                }, {
                    id: 53,
                    name: "Turret Gear",
                    topSprite: true,
                    price: 10000,
                    scale: 120,
                    desc: "you become a walking turret",
                    turret: {
                        proj: 1,
                        range: 700,
                        rate: 2500
                    },
                    spdMult: 0.7
                }, {
                    id: 20,
                    name: "Samurai Armor",
                    price: 12000,
                    scale: 120,
                    desc: "increased attack speed and fire rate",
                    atkSpd: 0.78
                }, {
                    id: 58,
                    name: "Dark Knight",
                    price: 12000,
                    scale: 120,
                    desc: "restores health when you deal damage",
                    healD: 0.4
                }, {
                    id: 27,
                    name: "Scavenger Gear",
                    price: 15000,
                    scale: 120,
                    desc: "earn double points for each kill",
                    kScrM: 2
                }, {
                    id: 40,
                    name: "Tank Gear",
                    price: 15000,
                    scale: 120,
                    desc: "increased damage to buildings but slower movement",
                    spdMult: 0.3,
                    bDmg: 3.3
                }, {
                    id: 52,
                    name: "Thief Gear",
                    price: 15000,
                    scale: 120,
                    desc: "steal half of a players gold when you kill them",
                    goldSteal: 0.5
                }, {
                    id: 55,
                    name: "Bloodthirster",
                    price: 20000,
                    scale: 120,
                    desc: "Restore Health when dealing damage. And increased damage",
                    healD: 0.25,
                    dmgMultO: 1.2,
                }, {
                    id: 56,
                    name: "Assassin Gear",
                    price: 20000,
                    scale: 120,
                    desc: "Go invisible when not moving. Can't eat. Increased speed",
                    noEat: true,
                    spdMult: 1.1,
                    invisTimer: 1000
                }];

                // STORE ACCESSORIES:
                this.accessories = [{
                    id: 12,
                    name: "Snowball",
                    price: 1000,
                    scale: 105,
                    xOff: 18,
                    desc: "no effect"
                }, {
                    id: 9,
                    name: "Tree Cape",
                    price: 1000,
                    scale: 90,
                    desc: "no effect"
                }, {
                    id: 10,
                    name: "Stone Cape",
                    price: 1000,
                    scale: 90,
                    desc: "no effect"
                }, {
                    id: 3,
                    name: "Cookie Cape",
                    price: 1500,
                    scale: 90,
                    desc: "no effect"
                }, {
                    id: 8,
                    name: "Cow Cape",
                    price: 2000,
                    scale: 90,
                    desc: "no effect"
                }, {
                    id: 11,
                    name: "Monkey Tail",
                    price: 2000,
                    scale: 97,
                    xOff: 25,
                    desc: "Super speed but reduced damage",
                    spdMult: 1.35,
                    dmgMultO: 0.2
                }, {
                    id: 17,
                    name: "Apple Basket",
                    price: 3000,
                    scale: 80,
                    xOff: 12,
                    desc: "slowly regenerates health over time",
                    healthRegen: 1
                }, {
                    id: 6,
                    name: "Winter Cape",
                    price: 3000,
                    scale: 90,
                    desc: "no effect"
                }, {
                    id: 4,
                    name: "Skull Cape",
                    price: 4000,
                    scale: 90,
                    desc: "no effect"
                }, {
                    id: 5,
                    name: "Dash Cape",
                    price: 5000,
                    scale: 90,
                    desc: "no effect"
                }, {
                    id: 2,
                    name: "Dragon Cape",
                    price: 6000,
                    scale: 90,
                    desc: "no effect"
                }, {
                    id: 1,
                    name: "Super Cape",
                    price: 8000,
                    scale: 90,
                    desc: "no effect"
                }, {
                    id: 7,
                    name: "Troll Cape",
                    price: 8000,
                    scale: 90,
                    desc: "no effect"
                }, {
                    id: 14,
                    name: "Thorns",
                    price: 10000,
                    scale: 115,
                    xOff: 20,
                    desc: "no effect"
                }, {
                    id: 15,
                    name: "Blockades",
                    price: 10000,
                    scale: 95,
                    xOff: 15,
                    desc: "no effect"
                }, {
                    id: 20,
                    name: "Devils Tail",
                    price: 10000,
                    scale: 95,
                    xOff: 20,
                    desc: "no effect"
                }, {
                    id: 16,
                    name: "Sawblade",
                    price: 12000,
                    scale: 90,
                    spin: true,
                    xOff: 0,
                    desc: "deal damage to players that damage you",
                    dmg: 0.15
                }, {
                    id: 13,
                    name: "Angel Wings",
                    price: 15000,
                    scale: 138,
                    xOff: 22,
                    desc: "slowly regenerates health over time",
                    healthRegen: 3
                }, {
                    id: 19,
                    name: "Shadow Wings",
                    price: 15000,
                    scale: 138,
                    xOff: 22,
                    desc: "increased movement speed",
                    spdMult: 1.1
                }, {
                    id: 18,
                    name: "Blood Wings",
                    price: 20000,
                    scale: 178,
                    xOff: 26,
                    desc: "restores health when you deal damage",
                    healD: 0.2
                }, {
                    id: 21,
                    name: "Corrupt X Wings",
                    price: 20000,
                    scale: 178,
                    xOff: 26,
                    desc: "deal damage to players that damage you",
                    dmg: 0.25
                }];
            }
        };
        let store = new Store();
        class ProjectileManager {
            constructor(Projectile, projectiles, players, ais, objectManager, items, config, Utils, server) {
                this.addProjectile = function(x, y, dir, range, speed, indx, owner, ignoreObj, layer) {
                    var tmpData = items.projectiles[indx];
                    var tmpProj = projectiles.find((tmp)=>!tmp.active);
                    if (!tmpProj) {
                        tmpProj = new Projectile(players,ais,objectManager,items,config,Utils,server);
                        tmpProj.sid = projectiles.length;
                        projectiles.push(tmpProj);
                    }
                    tmpProj.init(indx, x, y, dir, speed, tmpData.dmg, range, tmpData.scale, owner);
                    tmpProj.ignoreObj = ignoreObj;
                    tmpProj.layer = layer || tmpData.layer;
                    tmpProj.src = tmpData.src;
                    return tmpProj;
                };
            };
        }
        class AiManager {
            constructor(ais, AI, players, items, objectManager, config, UTILS, scoreCallback, server) {
                this.aiTypes = [{
                    id: 0,
                    src: "cow_1",
                    killScore: 150,
                    health: 500,
                    weightM: 0.8,
                    speed: 0.00095,
                    turnSpeed: 0.001,
                    scale: 72,
                    drop: ["food", 50]
                }, {
                    id: 1,
                    src: "pig_1",
                    killScore: 200,
                    health: 800,
                    weightM: 0.6,
                    speed: 0.00085,
                    turnSpeed: 0.001,
                    scale: 72,
                    drop: ["food", 80]
                }, {
                    id: 2,
                    name: "Bull",
                    src: "bull_2",
                    hostile: true,
                    dmg: 20,
                    killScore: 1000,
                    health: 1800,
                    weightM: 0.5,
                    speed: 0.00094,
                    turnSpeed: 0.00074,
                    scale: 78,
                    viewRange: 800,
                    chargePlayer: true,
                    drop: ["food", 100]
                }, {
                    id: 3,
                    name: "Bully",
                    src: "bull_1",
                    hostile: true,
                    dmg: 20,
                    killScore: 2000,
                    health: 2800,
                    weightM: 0.45,
                    speed: 0.001,
                    turnSpeed: 0.0008,
                    scale: 90,
                    viewRange: 900,
                    chargePlayer: true,
                    drop: ["food", 400]
                }, {
                    id: 4,
                    name: "Wolf",
                    src: "wolf_1",
                    hostile: true,
                    dmg: 8,
                    killScore: 500,
                    health: 300,
                    weightM: 0.45,
                    speed: 0.001,
                    turnSpeed: 0.002,
                    scale: 84,
                    viewRange: 800,
                    chargePlayer: true,
                    drop: ["food", 200]
                }, {
                    id: 5,
                    name: "Quack",
                    src: "chicken_1",
                    dmg: 8,
                    killScore: 2000,
                    noTrap: true,
                    health: 300,
                    weightM: 0.2,
                    speed: 0.0018,
                    turnSpeed: 0.006,
                    scale: 70,
                    drop: ["food", 100]
                }, {
                    id: 6,
                    name: "MOOSTAFA",
                    nameScale: 50,
                    src: "enemy",
                    hostile: true,
                    dontRun: true,
                    fixedSpawn: true,
                    spawnDelay: 60000,
                    noTrap: true,
                    colDmg: 100,
                    dmg: 40,
                    killScore: 8000,
                    health: 18000,
                    weightM: 0.4,
                    speed: 0.0007,
                    turnSpeed: 0.01,
                    scale: 80,
                    spriteMlt: 1.8,
                    leapForce: 0.9,
                    viewRange: 1000,
                    hitRange: 210,
                    hitDelay: 1000,
                    chargePlayer: true,
                    drop: ["food", 100]
                }, {
                    id: 7,
                    name: "Treasure",
                    hostile: true,
                    nameScale: 35,
                    src: "crate_1",
                    fixedSpawn: true,
                    spawnDelay: 120000,
                    colDmg: 200,
                    killScore: 5000,
                    health: 20000,
                    weightM: 0.1,
                    speed: 0.0,
                    turnSpeed: 0.0,
                    scale: 70,
                    spriteMlt: 1.0
                }, {
                    id: 8,
                    name: "MOOFIE",
                    src: "wolf_2",
                    hostile: true,
                    fixedSpawn: true,
                    dontRun: true,
                    hitScare: 4,
                    spawnDelay: 30000,
                    noTrap: true,
                    nameScale: 35,
                    dmg: 10,
                    colDmg: 100,
                    killScore: 3000,
                    health: 7000,
                    weightM: 0.45,
                    speed: 0.0015,
                    turnSpeed: 0.002,
                    scale: 90,
                    viewRange: 800,
                    chargePlayer: true,
                    drop: ["food", 1000]
                }, {
                    id: 9,
                    name: "MOOFIE",
                    src: "wolf_2",
                    hostile: true,
                    fixedSpawn: true,
                    dontRun: true,
                    hitScare: 50,
                    spawnDelay: 60000,
                    noTrap: true,
                    nameScale: 35,
                    dmg: 12,
                    colDmg: 100,
                    killScore: 3000,
                    health: 9000,
                    weightM: 0.45,
                    speed: 0.0015,
                    turnSpeed: 0.0025,
                    scale: 94,
                    viewRange: 1440,
                    chargePlayer: true,
                    drop: ["food", 3000]
                }, {
                    id: 10,
                    name: "Wolf",
                    src: "wolf_1",
                    hostile: true,
                    fixedSpawn: true,
                    dontRun: true,
                    hitScare: 50,
                    spawnDelay: 30000,
                    nameScale: 35,
                    dmg: 10,
                    killScore: 700,
                    health: 500,
                    weightM: 0.45,
                    speed: 0.00115,
                    turnSpeed: 0.0025,
                    scale: 88,
                    viewRange: 1440,
                    chargePlayer: true,
                    drop: ["food", 400]
                }, {
                    id: 11,
                    name: "Bully",
                    src: "bull_1",
                    hostile: true,
                    fixedSpawn: true,
                    dontRun: true,
                    hitScare: 50,
                    spawnDelay: 100000,
                    nameScale: 35,
                    dmg: 20,
                    killScore: 5000,
                    health: 5000,
                    weightM: 0.45,
                    speed: 0.0015,
                    turnSpeed: 0.0025,
                    scale: 94,
                    viewRange: 1440,
                    chargePlayer: true,
                    drop: ["food", 800]
                }];

                // SPAWN AI:
                this.spawn = function (x, y, dir, index) {
                    let tmpObj = ais.find((tmp) => !tmp.active);
                    if (!tmpObj) {
                        tmpObj = new AI(ais.length, objectManager, players, items, UTILS, config, scoreCallback, server);
                        ais.push(tmpObj);
                    }
                    tmpObj.init(x, y, dir, index, this.aiTypes[index]);
                    return tmpObj;
                };
            }

        };
        class AI {
            constructor(sid, objectManager, players, items, Utils, config, scoreCallback, server) {
                this.sid = sid;
                this.isAI = true;
                this.nameIndex = Utils.randInt(0, config.cowNames.length - 1);
                // INIT:
                this.init = function(x, y, dir, index, data) {
                    this.x = x;
                    this.y = y;
                    this.startX = data.fixedSpawn ? x : null;
                    this.startY = data.fixedSpawn ? y : null;
                    this.xVel = 0;
                    this.yVel = 0;
                    this.zIndex = 0;
                    this.dir = dir;
                    this.dirPlus = 0;
                    this.index = index;
                    this.src = data.src;
                    if (data.name) {
                        this.name = data.name;
                    }
                    this.weightM = data.weightM;
                    this.speed = data.speed;
                    this.killScore = data.killScore;
                    this.turnSpeed = data.turnSpeed;
                    this.scale = data.scale;
                    this.maxHealth = data.health;
                    this.leapForce = data.leapForce;
                    this.health = this.maxHealth;
                    this.chargePlayer = data.chargePlayer;
                    this.viewRange = data.viewRange;
                    this.drop = data.drop;
                    this.dmg = data.dmg;
                    this.hostile = data.hostile;
                    this.dontRun = data.dontRun;
                    this.hitRange = data.hitRange;
                    this.hitDelay = data.hitDelay;
                    this.hitScare = data.hitScare;
                    this.spriteMlt = data.spriteMlt;
                    this.nameScale = data.nameScale;
                    this.colDmg = data.colDmg;
                    this.noTrap = data.noTrap;
                    this.spawnDelay = data.spawnDelay;
                    this.hitWait = 0;
                    this.waitCount = 1000;
                    this.moveCount = 0;
                    this.weaponReload = 0;
                    this.weaponHitted = 0;
                    this.targetDir = 0;
                    this.active = true;
                    this.alive = true;
                    this.runFrom = null;
                    this.chargeTarget = null;
                    this.dmgOverTime = {};
                    this.doTickUpdate = false;
                }
                ;
                // UPDATE:
                var timerCount = 0;
                this.update = function(delta) {
                    if (this.active) {
                        // SPAWN DELAY:
                        if (this.spawnCounter) {
                            this.spawnCounter -= delta;
                            if (this.spawnCounter <= 0) {
                                this.spawnCounter = 0;
                                this.x = this.startX || Utils.randInt(0, config.mapScale);
                                this.y = this.startY || Utils.randInt(0, config.mapScale);
                            }
                            return;
                        }
                        // REGENS AND AUTO:
                        timerCount -= delta;
                        if (timerCount <= 0) {
                            if (this.dmgOverTime.dmg) {
                                this.changeHealth(-this.dmgOverTime.dmg, this.dmgOverTime.doer);
                                this.dmgOverTime.time -= 1;
                                if (this.dmgOverTime.time <= 0) {
                                    this.dmgOverTime.dmg = 0;
                                }
                            }
                            timerCount = 1000;
                        }
                        // BEHAVIOUR:
                        var charging = false;
                        var slowMlt = 1;
                        if (!this.zIndex && !this.lockMove && this.y >= config.mapScale / 2 - config.riverWidth / 2 && this.y <= config.mapScale / 2 + config.riverWidth / 2) {
                            slowMlt = 0.33;
                            this.xVel += config.waterCurrent * delta;
                        }
                        if (this.lockMove) {
                            this.xVel = 0;
                            this.yVel = 0;
                        } else if (this.waitCount > 0) {
                            this.waitCount -= delta;
                            if (this.waitCount <= 0) {
                                if (this.chargePlayer) {
                                    var tmpPlayer, bestDst, tmpDist;
                                    for (let i = 0; i < players.length; ++i) {
                                        if (players[i].alive && !(players[i].skin && players[i].skin.bullRepel)) {
                                            tmpDist = Utils.getDistance(this.x, this.y, players[i].x, players[i].y);
                                            if (tmpDist <= this.viewRange && (!tmpPlayer || tmpDist < bestDst)) {
                                                bestDst = tmpDist;
                                                tmpPlayer = players[i];
                                            }
                                        }
                                    }
                                    if (tmpPlayer) {
                                        this.chargeTarget = tmpPlayer;
                                        this.moveCount = Utils.randInt(8000, 12000);
                                    } else {
                                        this.moveCount = Utils.randInt(1000, 2000);
                                        this.targetDir = Utils.randFloat(-Math.PI, Math.PI);
                                    }
                                } else {
                                    this.moveCount = Utils.randInt(4000, 10000);
                                    this.targetDir = Utils.randFloat(-Math.PI, Math.PI);
                                }
                            }
                        } else if (this.moveCount > 0) {
                            var tmpSpd = this.speed * slowMlt;
                            if (this.runFrom && this.runFrom.active && !(this.runFrom.isPlayer && !this.runFrom.alive)) {
                                this.targetDir = Utils.getDirection(this.x, this.y, this.runFrom.x, this.runFrom.y);
                                tmpSpd *= 1.42;
                            } else if (this.chargeTarget && this.chargeTarget.alive) {
                                this.targetDir = Utils.getDirection(this.chargeTarget.x, this.chargeTarget.y, this.x, this.y);
                                tmpSpd *= 1.75;
                                charging = true;
                            }
                            if (this.hitWait) {
                                tmpSpd *= 0.3;
                            }
                            if (this.dir != this.targetDir) {
                                this.dir %= pi2;
                                var netAngle = (this.dir - this.targetDir + pi2) % pi2;
                                var amnt = min(abs(netAngle - pi2), netAngle, this.turnSpeed * delta);
                                var sign = netAngle - pi >= 0 ? 1 : -1;
                                this.dir += sign * amnt + pi2;
                            }
                            this.dir %= pi2;
                            this.xVel += tmpSpd * delta * cos(this.dir);
                            this.yVel += tmpSpd * delta * sin(this.dir);
                            this.moveCount -= delta;
                            if (this.moveCount <= 0) {
                                this.runFrom = null;
                                this.chargeTarget = null;
                                this.waitCount = this.hostile ? 1500 : Utils.randInt(1500, 6000);
                            }
                        }
                        // OBJECT COLL:
                        this.zIndex = 0;
                        this.lockMove = false;
                        var tmpList;
                        var tmpSpeed = Utils.getDistance(0, 0, this.xVel * delta, this.yVel * delta);
                        var depth = min(4, max(1, round(tmpSpeed / 40)));
                        var tMlt = 1 / depth;
                        for (let i = 0; i < depth; ++i) {
                            if (this.xVel) {
                                this.x += this.xVel * delta * tMlt;
                            }
                            if (this.yVel) {
                                this.y += this.yVel * delta * tMlt;
                            }
                            tmpList = objectManager.getGridArrays(this.x, this.y, this.scale);
                            for (var x = 0; x < tmpList.length; ++x) {
                                for (var y = 0; y < tmpList[x].length; ++y) {
                                    if (tmpList[x][y].active) {
                                        objectManager.checkCollision(this, tmpList[x][y], tMlt);
                                    }
                                }
                            }
                        }
                        // HITTING:
                        var hitting = false;
                        if (this.hitWait > 0) {
                            this.hitWait -= delta;
                            if (this.hitWait <= 0) {
                                hitting = true;
                                this.hitWait = 0;
                                if (this.leapForce && !Utils.randInt(0, 2)) {
                                    this.xVel += this.leapForce * cos(this.dir);
                                    this.yVel += this.leapForce * sin(this.dir);
                                }
                                let tmpList = objectManager.getGridArrays(this.x, this.y, this.hitRange);
                                var tmpObj, tmpDst;
                                for (var t = 0; t < tmpList.length; ++t) {
                                    for (let x = 0; x < tmpList[t].length; ++x) {
                                        tmpObj = tmpList[t][x];
                                        if (tmpObj.health) {
                                            tmpDst = Utils.getDistance(this.x, this.y, tmpObj.x, tmpObj.y);
                                            if (tmpDst < tmpObj.scale + this.hitRange) {
                                                if (tmpObj.changeHealth(-this.dmg * 5)) {
                                                    objectManager.disableObj(tmpObj);
                                                }
                                                objectManager.hitObj(tmpObj, Utils.getDirection(this.x, this.y, tmpObj.x, tmpObj.y));
                                            }
                                        }
                                    }
                                }
                                for (let x = 0; x < players.length; ++x) {
                                    if (players[x].canSee(this)) {
                                        server.send(players[x].id, "aa", this.sid);
                                    }
                                }
                            }
                        }
                        // PLAYER COLLISIONS:
                        if (charging || hitting) {
                            let tmpObj, tmpDst, tmpDir;
                            for (let i = 0; i < players.length; ++i) {
                                tmpObj = players[i];
                                if (tmpObj && tmpObj.alive) {
                                    tmpDst = Utils.getDistance(this.x, this.y, tmpObj.x, tmpObj.y);
                                    if (this.hitRange) {
                                        if (!this.hitWait && tmpDst <= this.hitRange + tmpObj.scale) {
                                            if (hitting) {
                                                tmpDir = Utils.getDirection(tmpObj.x, tmpObj.y, this.x, this.y);
                                                tmpObj.changeHealth(-this.dmg);
                                                tmpObj.xVel += 0.6 * cos(tmpDir);
                                                tmpObj.yVel += 0.6 * sin(tmpDir);
                                                this.runFrom = null;
                                                this.chargeTarget = null;
                                                this.waitCount = 3000;
                                                this.hitWait = !Utils.randInt(0, 2) ? 600 : 0;
                                            } else {
                                                this.hitWait = this.hitDelay;
                                            }
                                        }
                                    } else if (tmpDst <= this.scale + tmpObj.scale) {
                                        tmpDir = Utils.getDirection(tmpObj.x, tmpObj.y, this.x, this.y);
                                        tmpObj.changeHealth(-this.dmg);
                                        tmpObj.xVel += 0.55 * cos(tmpDir);
                                        tmpObj.yVel += 0.55 * sin(tmpDir);
                                    }
                                }
                            }
                        }
                        // DECEL:
                        if (this.xVel) {
                            this.xVel *= pow(config.playerDecel, delta);
                        }
                        if (this.yVel) {
                            this.yVel *= pow(config.playerDecel, delta);
                        }
                        // MAP BOUNDARIES:
                        var tmpScale = this.scale;
                        if (this.x - tmpScale < 0) {
                            this.x = tmpScale;
                            this.xVel = 0;
                        } else if (this.x + tmpScale > config.mapScale) {
                            this.x = config.mapScale - tmpScale;
                            this.xVel = 0;
                        }
                        if (this.y - tmpScale < 0) {
                            this.y = tmpScale;
                            this.yVel = 0;
                        } else if (this.y + tmpScale > config.mapScale) {
                            this.y = config.mapScale - tmpScale;
                            this.yVel = 0;
                        }
                    }
                }
                ;
                // CAN SEE:
                this.canSee = function(other) {
                    if (!other) {
                        return false;
                    }
                    if (other.skin && other.skin.invisTimer && other.noMovTimer >= other.skin.invisTimer) {
                        return false;
                    }
                    var dx = abs(other.x - this.x) - other.scale;
                    var dy = abs(other.y - this.y) - other.scale;
                    return (dx <= (config.maxScreenWidth / 2) * 1.3 && dy <= (config.maxScreenHeight / 2) * 1.3);
                }
                ;
                var tmpRatio = 0;
                var animIndex = 0;
                this.animate = function(delta) {
                    if (this.animTime > 0) {
                        this.animTime -= delta;
                        if (this.animTime <= 0) {
                            this.animTime = 0;
                            this.dirPlus = 0;
                            tmpRatio = 0;
                            animIndex = 0;
                        } else {
                            if (animIndex == 0) {
                                tmpRatio += delta / (this.animSpeed * config.hitReturnRatio);
                                this.dirPlus = Utils.lerp(0, this.targetAngle, min(1, tmpRatio));
                                if (tmpRatio >= 1) {
                                    tmpRatio = 1;
                                    animIndex = 1;
                                }
                            } else {
                                tmpRatio -= delta / (this.animSpeed * (1 - config.hitReturnRatio));
                                this.dirPlus = Utils.lerp(0, this.targetAngle, max(0, tmpRatio));
                            }
                        }
                    }
                }
                ;
                // ANIMATION:
                this.startAnim = function() {
                    this.animTime = this.animSpeed = 600;
                    this.targetAngle = pi * 0.8;
                    tmpRatio = 0;
                    animIndex = 0;
                }
                ;
                // CHANGE HEALTH:
                this.changeHealth = function(val, doer, runFrom) {
                    if (this.active) {
                        this.health += val;
                        if (runFrom) {
                            if (this.hitScare && !Utils.randInt(0, this.hitScare)) {
                                this.runFrom = runFrom;
                                this.waitCount = 0;
                                this.moveCount = 2000;
                            } else if (this.hostile && this.chargePlayer && runFrom.isPlayer) {
                                this.chargeTarget = runFrom;
                                this.waitCount = 0;
                                this.moveCount = 8000;
                            } else if (!this.dontRun) {
                                this.runFrom = runFrom;
                                this.waitCount = 0;
                                this.moveCount = 2000;
                            }
                        }
                        if (val < 0 && this.hitRange && Utils.randInt(0, 1)) {
                            this.hitWait = 500;
                        }
                        if (doer && doer.canSee(this) && val < 0) {
                            server.send(doer.id, "J", round(this.x), round(this.y), round(-val), 1);
                        }
                        if (this.health <= 0) {
                            if (this.spawnDelay) {
                                this.spawnCounter = this.spawnDelay;
                                this.x = -1000000;
                                this.y = -1000000;
                            } else {
                                this.x = this.startX || Utils.randInt(0, config.mapScale);
                                this.y = this.startY || Utils.randInt(0, config.mapScale);
                            }
                            this.health = this.maxHealth;
                            this.runFrom = null;
                            if (doer) {
                                scoreCallback(doer, this.killScore);
                                if (this.drop) {
                                    for (let i = 0; i < this.drop.length; ) {
                                        doer.addResource(config.resourceTypes.indexOf(this.drop[i]), this.drop[i + 1]);
                                        i += 2;
                                    }
                                }
                            }
                        }
                    }
                };
            }
        };
        class Player {
            constructor(id, sid, config, Utils, projectileManager, objectManager, players, ais, items, hats, accessories, server, scoreCallback, iconCallback) {
                this.id = id;
                this.sid = sid;
                this.tmpScore = 0;
                this.team = null;
                this.skinIndex = 0;
                this.tailIndex = 0;
                this.hitTime = 0;
                this.tails = {};
                for (let i = 0; i < accessories.length; ++i) {
                    if (accessories[i].price <= 0) {
                        this.tails[accessories[i].id] = 1;
                    }
                }
                this.skins = {};
                for (let i = 0; i < hats.length; ++i) {
                    if (hats[i].price <= 0) {
                        this.skins[hats[i].id] = 1;
                    }
                }
                this.points = 0;
                this.dt = 0;
                this.rt = 0;
                this.hidden = false;
                this.itemCounts = {};
                this.isPlayer = true;
                this.pps = 0;
                this.moveDir = undefined;
                this.skinRot = 0;
                this.lastPing = 0;
                this.iconIndex = 0;
                this.skinColor = 0;
                this.dangerShame = 5;
                this.projDist = 0;
                // SPAWN:
                this.spawn = function(moofoll) {
                    // ADDED MODULES:
                    this.holdWeapon = 0;
                    this.finded = 0;
                    this.syncThreats = 0;
                    this.primaryIndex = undefined;
                    this.secondaryIndex = undefined;
                    this.primaryVariant = undefined;
                    this.secondaryVariant = undefined;
                    this.gatherIndex = undefined;
                    this.shootIndex = undefined;
                    this.bowThreat = {
                        9: 0,
                        12: 0,
                        13: 0,
                        15: 0,
                    };
                    this.aim2 = 0;
                    this.dist2 = 0;
                    this.aim3 = 0;
                    this.dist3 = 0;
                    this.notHere = false;
                    this.bTick = 0;
                    this.pCount = 0;
                    this.hitted = false;
                    this.anti = false;
                    this.healSid = -1;
                    this.damaged = false;
                    this.active = true;
                    this.alive = true;
                    this.lockMove = false;
                    this.lockDir = false;
                    this.minimapCounter = 0;
                    this.chatCountdown = 0;
                    this.shameCount = 0;
                    this.shameTimer = 0;
                    this.antiClown = 4;
                    this.maxShame = 7;
                    this.sentTo = {};
                    this.gathering = 0;
                    this.shooting = {};
                    this.autoGather = 0;
                    this.animTime = 0;
                    this.animSpeed = 0;
                    this.mouseState = 0;
                    this.buildIndex = -1;
                    this.weaponIndex = 0;
                    this.dmgOverTime = {};
                    this.noMovTimer = 0;
                    this.maxXP = 300;
                    this.XP = 0;
                    this.age = 1;
                    this.kills = 0;
                    this.upgrAge = 2;
                    this.upgradePoints = 0;
                    this.x = 0;
                    this.y = 0;
                    this.zIndex = 0;
                    this.xVel = 0;
                    this.yVel = 0;
                    this.slowMult = 1;
                    this.dir = 0;
                    this.dirPlus = 0;
                    this.targetDir = 0;
                    this.targetAngle = 0;
                    this.maxHealth = 100;
                    this.health = this.maxHealth;
                    this.scale = config.playerScale;
                    this.speed = config.playerSpeed;
                    this.resetMoveDir();
                    this.resetResources(moofoll);
                    this.firstItems = [0, 3, 6, 10];
                    this.items = [0, 3, 6, 10];
                    this.weapons = [0];
                    this.shootCount = 0;
                    this.weaponXP = [];
                    this.reloads = {
                        0: 0,
                        1: 0,
                        2: 0,
                        3: 0,
                        4: 0,
                        5: 0,
                        6: 0,
                        7: 0,
                        8: 0,
                        9: 0,
                        10: 0,
                        11: 0,
                        12: 0,
                        13: 0,
                        14: 0,
                        15: 0,
                        53: 0,
                    };
                    this.oldReloads = {
                        0: 0,
                        1: 0,
                        2: 0,
                        3: 0,
                        4: 0,
                        5: 0,
                        6: 0,
                        7: 0,
                        8: 0,
                        9: 0,
                        10: 0,
                        11: 0,
                        12: 0,
                        13: 0,
                        14: 0,
                        15: 0,
                        53: 0,
                    };
                    this.turretReloaded = false;
                    this.doTickUpdate = false;
                }
                ;
                // RESET MOVE DIR:
                this.resetMoveDir = function() {
                    this.moveDir = undefined;
                }
                ;
                // RESET RESOURCES:
                this.resetResources = function(moofoll) {
                    for (let i = 0; i < config.resourceTypes.length; ++i) {
                        this[config.resourceTypes[i]] = moofoll ? 100 : 0;
                    }
                }
                ;
                // ADD ITEM:
                this.addItem = function(id) {
                    var tmpItem = items.list[id];
                    if (tmpItem) {
                        for (let i = 0; i < this.items.length; ++i) {
                            if (items.list[this.items[i]].group == tmpItem.group) {
                                if (this.buildIndex == this.items[i]) {
                                    this.buildIndex = id;
                                }
                                this.items[i] = id;
                                return true;
                            }
                        }
                        this.items.push(id);
                        return true;
                    }
                    return false;
                }
                ;
                this.getItemType = function(id) {
                    let findindx = this.items.findIndex((ids) => ids == id);
                    if (findindx != -1) {
                        return findindx;
                    } else {
                        return items.checkItem.index(id, this.items);
                    }
                };
                // GET DATA TO SEND:
                this.getData = function() {
                    return [this.id, this.sid, this.name, Utils.fixTo(this.x, 2), Utils.fixTo(this.y, 2), Utils.fixTo(this.dir, 3), this.health, this.maxHealth, this.scale, this.skinColor, ];
                }
                ;
                // SET DATA:
                this.setData = function(data) {
                    this.id = data[0];
                    this.sid = data[1];
                    this.name = data[2];
                    this.x = data[3];
                    this.y = data[4];
                    this.dir = data[5];
                    this.health = data[6];
                    this.maxHealth = data[7];
                    this.scale = data[8];
                    this.skinColor = data[9];
                }
                ;
                // UPDATE:
                var timerCount = 0;
                this.update = function(delta) {
                    if (!this.alive) return;
                    // SHAME SHAME SHAME:
                    if (this.shameTimer > 0) {
                        this.shameTimer -= delta;
                        if (this.shameTimer <= 0) {
                            this.shameTimer = 0;
                            this.shameCount = 0;
                        }
                    }
                    // REGENS AND AUTO:
                    timerCount -= delta;
                    if (timerCount <= 0) {
                        var regenAmount = (this.skin && this.skin.healthRegen ? this.skin.healthRegen : 0) + (this.tail && this.tail.healthRegen ? this.tail.healthRegen : 0);
                        if (regenAmount) {
                            this.changeHealth(regenAmount, this);
                        }
                        if (this.dmgOverTime.dmg) {
                            this.changeHealth(-this.dmgOverTime.dmg, this.dmgOverTime.doer);
                            this.dmgOverTime.time -= 1;
                            if (this.dmgOverTime.time <= 0) {
                                this.dmgOverTime.dmg = 0;
                            }
                        }
                        if (this.healCol) {
                            this.changeHealth(this.healCol, this);
                        }
                        timerCount = 1000;
                    }
                    // CHECK KILL:
                    if (!this.alive) return;
                    // SLOWER:
                    if (this.slowMult < 1) {
                        this.slowMult += 0.0008 * delta;
                        if (this.slowMult > 1) {
                            this.slowMult = 1;
                        }
                    }
                    // MOVE:
                    this.noMovTimer += delta;
                    if (this.xVel || this.yVel) {
                        this.noMovTimer = 0;
                    }
                    if (this.lockMove) {
                        this.xVel = 0;
                        this.yVel = 0;
                    } else {
                        var spdMult = (this.buildIndex >= 0 ? 0.5 : 1) * (items.weapons[this.weaponIndex].spdMult || 1) * (this.skin ? this.skin.spdMult || 1 : 1) * (this.tail ? this.tail.spdMult || 1 : 1) * (this.y <= config.snowBiomeTop ? this.skin && this.skin.coldM ? 1 : config.snowSpeed : 1) * this.slowMult;
                        if (!this.zIndex && this.y >= config.mapScale / 2 - config.riverWidth / 2 && this.y <= config.mapScale / 2 + config.riverWidth / 2) {
                            if (this.skin && this.skin.watrImm) {
                                spdMult *= 0.75;
                                this.xVel += config.waterCurrent * 0.4 * delta;
                            } else {
                                spdMult *= 0.33;
                                this.xVel += config.waterCurrent * delta;
                            }
                        }
                        var xVel = this.moveDir != undefined ? cos(this.moveDir) : 0;
                        var yVel = this.moveDir != undefined ? sin(this.moveDir) : 0;
                        var length = sqrt(xVel * xVel + yVel * yVel);
                        if (length != 0) {
                            xVel /= length;
                            yVel /= length;
                        }
                        if (xVel) {
                            this.xVel += xVel * this.speed * spdMult * delta;
                        }
                        if (yVel) {
                            this.yVel += yVel * this.speed * spdMult * delta;
                        }
                    }
                    // OBJECT COLL:
                    this.zIndex = 0;
                    this.lockMove = false;
                    this.healCol = 0;
                    var tmpList;
                    var tmpSpeed = Utils.getDistance(0, 0, this.xVel * delta, this.yVel * delta);
                    var depth = min(4, max(1, round(tmpSpeed / 40)));
                    var tMlt = 1 / depth;
                    for (let i = 0; i < depth; ++i) {
                        if (this.xVel) {
                            this.x += this.xVel * delta * tMlt;
                        }
                        if (this.yVel) {
                            this.y += this.yVel * delta * tMlt;
                        }
                        tmpList = objectManager.getGridArrays(this.x, this.y, this.scale);
                        for (var x = 0; x < tmpList.length; ++x) {
                            for (var y = 0; y < tmpList[x].length; ++y) {
                                if (tmpList[x][y].active) {
                                    objectManager.checkCollision(this, tmpList[x][y], tMlt);
                                }
                            }
                        }
                    }
                    // PLAYER COLLISIONS:
                    var tmpIndx = players.indexOf(this);
                    for (let i = tmpIndx + 1; i < players.length; ++i) {
                        if (players[i] != this && players[i].alive) {
                            objectManager.checkCollision(this, players[i]);
                        }
                    }
                    // DECEL:
                    if (this.xVel) {
                        this.xVel *= pow(config.playerDecel, delta);
                        if (this.xVel <= 0.01 && this.xVel >= -0.01) {
                            this.xVel = 0;
                        }
                    }
                    if (this.yVel) {
                        this.yVel *= pow(config.playerDecel, delta);
                        if (this.yVel <= 0.01 && this.yVel >= -0.01) {
                            this.yVel = 0;
                        }
                    }
                    // MAP BOUNDARIES:
                    if (this.x - this.scale < 0) {
                        this.x = this.scale;
                    } else if (this.x + this.scale > config.mapScale) {
                        this.x = config.mapScale - this.scale;
                    }
                    if (this.y - this.scale < 0) {
                        this.y = this.scale;
                    } else if (this.y + this.scale > config.mapScale) {
                        this.y = config.mapScale - this.scale;
                    }
                    // USE WEAPON OR TOOL:
                    if (this.buildIndex < 0) {
                        if (this.reloads[this.weaponIndex] > 0) {
                            this.reloads[this.weaponIndex] -= delta;
                            this.gathering = this.mouseState;
                        } else if (this.gathering || this.autoGather) {
                            var worked = true;
                            if (items.weapons[this.weaponIndex].gather != undefined) {
                                this.gather(players);
                            } else if (items.weapons[this.weaponIndex].projectile != undefined && this.hasRes(items.weapons[this.weaponIndex], this.skin ? this.skin.projCost : 0)) {
                                this.useRes(items.weapons[this.weaponIndex], this.skin ? this.skin.projCost : 0);
                                this.noMovTimer = 0;
                                let tmpIndx = items.weapons[this.weaponIndex].projectile;
                                let projOffset = this.scale * 2;
                                let aMlt = this.skin && this.skin.aMlt ? this.skin.aMlt : 1;
                                if (items.weapons[this.weaponIndex].rec) {
                                    this.xVel -= items.weapons[this.weaponIndex].rec * cos(this.dir);
                                    this.yVel -= items.weapons[this.weaponIndex].rec * sin(this.dir);
                                }
                                projectileManager.addProjectile(this.x + projOffset * cos(this.dir), this.y + projOffset * sin(this.dir), this.dir, items.projectiles[tmpIndx].range * aMlt, items.projectiles[tmpIndx].speed * aMlt, tmpIndx, this, null, this.zIndex);
                            } else {
                                worked = false;
                            }
                            this.gathering = this.mouseState;
                            if (worked) {
                                this.reloads[this.weaponIndex] = items.weapons[this.weaponIndex].speed * (this.skin ? this.skin.atkSpd || 1 : 1);
                            }
                        }
                    }
                }
                ;
                // ADD WEAPON XP:
                this.addWeaponXP = function(amnt) {
                    if (!this.weaponXP[this.weaponIndex]) {
                        this.weaponXP[this.weaponIndex] = 0;
                    }
                    this.weaponXP[this.weaponIndex] += amnt;
                    if (this.weaponIndex == this.weapons[0]) {
                        getEl("priXP").innerHTML = "Primary XP: " + this.weaponXP[this.weapons[0]] + " / " + config.weaponXPs[this.weaponVariant].xp;
                    } else if (this.weaponIndex == this.weapons[1]) {
                        getEl("secXP").innerHTML = "Secondary XP: " + this.weaponXP[this.weapons[1]] + " / " + config.weaponXPs[this.weaponVariant].xp;
                    }
                }
                ;
                // EARN XP:
                this.earnXP = function(amount) {
                    if (this.age < config.maxAge) {
                        this.XP += amount;
                        if (this.XP >= this.maxXP) {
                            if (this.age < config.maxAge) {
                                this.age++;
                                this.XP = 0;
                                this.maxXP *= 1.2;
                            } else {
                                this.XP = this.maxXP;
                            }
                            this.upgradePoints++;
                            server.send(this.id, "U", this.upgradePoints, this.upgrAge);
                            server.send(this.id, "T", this.XP, Utils.fixTo(this.maxXP, 1), this.age);
                        } else {
                            server.send(this.id, "T", this.XP);
                        }
                    }
                }
                ;
                // CHANGE HEALTH:
                this.changeHealth = function(amount, doer) {
                    if (amount > 0 && this.health >= this.maxHealth) {
                        return false;
                    }
                    if (amount < 0 && this.skin) {
                        amount *= this.skin.dmgMult || 1;
                    }
                    if (amount < 0 && this.tail) {
                        amount *= this.tail.dmgMult || 1;
                    }
                    if (amount < 0) {
                        this.hitTime = Date.now();
                    }
                    this.health += amount;
                    if (this.health > this.maxHealth) {
                        amount -= this.health - this.maxHealth;
                        this.health = this.maxHealth;
                    }
                    if (this.health <= 0) {
                        this.kill(doer);
                    }
                    for (let i = 0; i < players.length; ++i) {
                        if (this.sentTo[players[i].id]) {
                            server.send(players[i].id, "O", this.sid, round(this.health));
                        }
                    }
                    if (doer && doer.canSee(this) && !(doer == this && amount < 0)) {
                        server.send(doer.id, "8", round(this.x), round(this.y), round(-amount), 1);
                    }
                    return true;
                };
                // KILL:
                this.kill = function(doer) {
                    if (doer && doer.alive) {
                        doer.kills++;
                        if (doer.skin && doer.skin.goldSteal) {
                            scoreCallback(doer, round(this.points / 2));
                        } else {
                            scoreCallback(doer, round(this.age * 100 * (doer.skin && doer.skin.kScrM ? doer.skin.kScrM : 1)));
                        }
                        server.send(doer.id, "N", "kills", doer.kills, 1);
                    }
                    this.alive = false;
                    server.send(this.id, "P");
                    iconCallback();
                }
                ;
                // ADD RESOURCE:
                this.addResource = function(type, amount, auto) {
                    if (!auto && amount > 0) {
                        this.addWeaponXP(amount);
                    }
                    if (type == 3) {
                        scoreCallback(this, amount, true);
                    } else {
                        this[config.resourceTypes[type]] += amount;
                        server.send(this.id, "N", config.resourceTypes[type], this[config.resourceTypes[type]], 1);
                    }
                }
                ;
                // CHANGE ITEM COUNT:
                this.changeItemCount = function(index, value) {
                    this.itemCounts[index] = this.itemCounts[index] || 0;
                    this.itemCounts[index] += value;
                    server.send(this.id, "S", index, this.itemCounts[index]);
                }
                ;
                // BUILD:
                this.buildItem = function(item) {
                    var tmpS = this.scale + item.scale + (item.placeOffset || 0);
                    var tmpX = this.x + tmpS * cos(this.dir);
                    var tmpY = this.y + tmpS * sin(this.dir);
                    if (this.canBuild(item) && !(item.consume && this.skin && this.skin.noEat) && (item.consume || objectManager.checkItemLocation(tmpX, tmpY, item.scale, 0.6, item.id, false, this))) {
                        var worked = false;
                        if (item.consume) {
                            if (this.hitTime) {
                                var timeSinceHit = Date.now() - this.hitTime;
                                this.hitTime = 0;
                                if (timeSinceHit <= 120) {
                                    this.shameCount++;
                                    if (this.shameCount >= 8) {
                                        this.shameTimer = 30000;
                                        this.shameCount = 0;
                                    }
                                } else {
                                    this.shameCount -= 2;
                                    if (this.shameCount <= 0) {
                                        this.shameCount = 0;
                                    }
                                }
                            }
                            if (this.shameTimer <= 0) {
                                worked = item.consume(this);
                            }
                        } else {
                            worked = true;
                            if (item.group.limit) {
                                this.changeItemCount(item.group.id, 1);
                            }
                            if (item.pps) {
                                this.pps += item.pps;
                            }
                            objectManager.add(objectManager.objects.length, tmpX, tmpY, this.dir, item.scale, item.type, item, false, this);
                        }
                        if (worked) {
                            this.useRes(item);
                            this.buildIndex = -1;
                        }
                    }
                }
                ;
                // HAS RESOURCES:
                this.hasRes = function(item, mult) {
                    for (let i = 0; i < item.req.length; ) {
                        if (this[item.req[i]] < round(item.req[i + 1] * (mult || 1))) {
                            return false;
                        }
                        i += 2;
                    }
                    return true;
                }
                ;
                // USE RESOURCES:
                this.useRes = function(item, mult) {
                    if (config.inSandbox) return;
                    for (let i = 0; i < item.req.length; ) {
                        this.addResource(config.resourceTypes.indexOf(item.req[i]), -round(item.req[i + 1] * (mult || 1)));
                        i += 2;
                    }
                }
                ;
                // CAN BUILD:
                this.canBuild = function(item) {
                    if (config.inSandbox) {
                        return true;
                    }
                    if (item.group.limit && this.itemCounts[item.group.id] >= item.group.limit) {
                        return false;
                    }
                    return this.hasRes(item);
                }
                ;
                // GATHER:
                this.gather = function() {
                    // SHOW:
                    this.noMovTimer = 0;
                    // SLOW MOVEMENT:
                    this.slowMult -= items.weapons[this.weaponIndex].hitSlow || 0.3;
                    if (this.slowMult < 0) {
                        this.slowMult = 0;
                    }
                    // VARIANT DMG:
                    var tmpVariant = config.fetchVariant(this);
                    var applyPoison = tmpVariant.poison;
                    var variantDmg = tmpVariant.val;
                    // CHECK IF HIT GAME OBJECT:
                    var hitObjs = {};
                    var tmpDist, tmpDir, tmpObj, hitSomething;
                    var tmpList = objectManager.getGridArrays(this.x, this.y, items.weapons[this.weaponIndex].range);
                    for (var t = 0; t < tmpList.length; ++t) {
                        for (let i = 0; i < tmpList[t].length; ++i) {
                            tmpObj = tmpList[t][i];
                            if (tmpObj.active && !tmpObj.dontGather && !hitObjs[tmpObj.sid] && tmpObj.visibleToPlayer(this)) {
                                tmpDist = Utils.getDistance(this.x, this.y, tmpObj.x, tmpObj.y) - tmpObj.scale;
                                if (tmpDist <= items.weapons[this.weaponIndex].range) {
                                    tmpDir = Utils.getDirection(tmpObj.x, tmpObj.y, this.x, this.y);
                                    if (Utils.getAngleDist(tmpDir, this.dir) <= config.gatherAngle) {
                                        hitObjs[tmpObj.sid] = 1;
                                        if (tmpObj.health) {
                                            if (tmpObj.changeHealth(-items.weapons[this.weaponIndex].dmg * variantDmg * (items.weapons[this.weaponIndex].sDmg || 1) * (this.skin && this.skin.bDmg ? this.skin.bDmg : 1), this)) {
                                                for (var x = 0; x < tmpObj.req.length; ) {
                                                    this.addResource(config.resourceTypes.indexOf(tmpObj.req[x]), tmpObj.req[x + 1]);
                                                    x += 2;
                                                }
                                                objectManager.disableObj(tmpObj);
                                            }
                                        } else {
                                            this.earnXP(4 * items.weapons[this.weaponIndex].gather);
                                            var count = items.weapons[this.weaponIndex].gather + (tmpObj.type == 3 ? 4 : 0);
                                            if (this.skin && this.skin.extraGold) {
                                                this.addResource(3, 1);
                                            }
                                            this.addResource(tmpObj.type, count);
                                        }
                                        hitSomething = true;
                                        objectManager.hitObj(tmpObj, tmpDir);
                                    }
                                }
                            }
                        }
                    }
                    // CHECK IF HIT PLAYER:
                    for (let i = 0; i < players.length + ais.length; ++i) {
                        tmpObj = players[i] || ais[i - players.length];
                        if (tmpObj != this && tmpObj.alive && !(tmpObj.team && tmpObj.team == this.team)) {
                            tmpDist = Utils.getDistance(this.x, this.y, tmpObj.x, tmpObj.y) - tmpObj.scale * 1.8;
                            if (tmpDist <= items.weapons[this.weaponIndex].range) {
                                tmpDir = Utils.getDirection(tmpObj.x, tmpObj.y, this.x, this.y);
                                if (Utils.getAngleDist(tmpDir, this.dir) <= config.gatherAngle) {
                                    // STEAL RESOURCES:
                                    var stealCount = items.weapons[this.weaponIndex].steal;
                                    if (stealCount && tmpObj.addResource) {
                                        stealCount = min(tmpObj.points || 0, stealCount);
                                        this.addResource(3, stealCount);
                                        tmpObj.addResource(3, -stealCount);
                                    }
                                    // MELEE HIT PLAYER:
                                    var dmgMlt = variantDmg;
                                    if (tmpObj.weaponIndex != undefined && items.weapons[tmpObj.weaponIndex].shield && Utils.getAngleDist(tmpDir + pi, tmpObj.dir) <= config.shieldAngle) {
                                        dmgMlt = items.weapons[tmpObj.weaponIndex].shield;
                                    }
                                    var dmgVal = items.weapons[this.weaponIndex].dmg * (this.skin && this.skin.dmgMultO ? this.skin.dmgMultO : 1) * (this.tail && this.tail.dmgMultO ? this.tail.dmgMultO : 1);
                                    var tmpSpd = 0.3 * (tmpObj.weightM || 1) + (items.weapons[this.weaponIndex].knock || 0);
                                    tmpObj.xVel += tmpSpd * cos(tmpDir);
                                    tmpObj.yVel += tmpSpd * sin(tmpDir);
                                    if (this.skin && this.skin.healD) {
                                        this.changeHealth(dmgVal * dmgMlt * this.skin.healD, this);
                                    }
                                    if (this.tail && this.tail.healD) {
                                        this.changeHealth(dmgVal * dmgMlt * this.tail.healD, this);
                                    }
                                    if (tmpObj.skin && tmpObj.skin.dmg && dmgMlt == 1) {
                                        this.changeHealth(-dmgVal * tmpObj.skin.dmg, tmpObj);
                                    }
                                    if (tmpObj.tail && tmpObj.tail.dmg && dmgMlt == 1) {
                                        this.changeHealth(-dmgVal * tmpObj.tail.dmg, tmpObj);
                                    }
                                    if (tmpObj.dmgOverTime && this.skin && this.skin.poisonDmg && !(tmpObj.skin && tmpObj.skin.poisonRes)) {
                                        tmpObj.dmgOverTime.dmg = this.skin.poisonDmg;
                                        tmpObj.dmgOverTime.time = this.skin.poisonTime || 1;
                                        tmpObj.dmgOverTime.doer = this;
                                    }
                                    if (tmpObj.dmgOverTime && applyPoison && !(tmpObj.skin && tmpObj.skin.poisonRes)) {
                                        tmpObj.dmgOverTime.dmg = 5;
                                        tmpObj.dmgOverTime.time = 5;
                                        tmpObj.dmgOverTime.doer = this;
                                    }
                                    if (tmpObj.skin && tmpObj.skin.dmgK) {
                                        this.xVel -= tmpObj.skin.dmgK * cos(tmpDir);
                                        this.yVel -= tmpObj.skin.dmgK * sin(tmpDir);
                                    }
                                    tmpObj.changeHealth(-dmgVal * dmgMlt, this, this);
                                }
                            }
                        }
                    }
                    // SEND FOR ANIMATION:
                    this.sendAnimation(hitSomething ? 1 : 0);
                }
                ;
                // SEND ANIMATION:
                this.sendAnimation = function(hit) {
                    for (let i = 0; i < players.length; ++i) {
                        if (this.sentTo[players[i].id] && this.canSee(players[i])) {
                            server.send(players[i].id, "7", this.sid, hit ? 1 : 0, this.weaponIndex);
                        }
                    }
                }
                ;
                // ANIMATE:
                var tmpRatio = 0;
                var animIndex = 0;
                this.animate = function(delta) {
                    if (this.animTime > 0) {
                        this.animTime -= delta;
                        if (this.animTime <= 0) {
                            this.animTime = 0;
                            this.dirPlus = 0;
                            tmpRatio = 0;
                            animIndex = 0;
                        } else {
                            if (animIndex == 0) {
                                tmpRatio += delta / (this.animSpeed * config.hitReturnRatio);
                                this.dirPlus = Utils.lerp(0, this.targetAngle, min(1, tmpRatio));
                                if (tmpRatio >= 1) {
                                    tmpRatio = 1;
                                    animIndex = 1;
                                }
                            } else {
                                tmpRatio -= delta / (this.animSpeed * (1 - config.hitReturnRatio));
                                this.dirPlus = Utils.lerp(0, this.targetAngle, max(0, tmpRatio));
                            }
                        }
                    }
                }
                ;
                // GATHER ANIMATION:
                this.startAnim = function(didHit, index) {
                    this.animTime = this.animSpeed = items.weapons[index].speed;
                    this.targetAngle = didHit ? -config.hitAngle : -pi;
                    tmpRatio = 0;
                    animIndex = 0;
                }
                ;
                // CAN SEE:
                this.canSee = function(other) {
                    if (!other) {
                        return false;
                    }
                    if (other.skin && other.skin.invisTimer && other.noMovTimer >= other.skin.invisTimer){
                        return false;
                    }
                    var dx = abs(other.x - this.x) - other.scale;
                    var dy = abs(other.y - this.y) - other.scale;
                    return (dx <= (config.maxScreenWidth / 2) * 1.3 && dy <= (config.maxScreenHeight / 2) * 1.3);
                };

                this.isTeam = function (tmpObj) {
                    return (this == tmpObj || (this.team && this.team == tmpObj.team));
                };
            };
        }
        class MapManager {
            constructor() {
            }
        }
        var isProd = location.hostname !== "127.0.0.1" && !location.hostname.startsWith("192.168.");
        var connected = false;
        var startedConnecting = false;

        function socketReady() {
            return (io.connected);
        }

        function joinParty() {
            var currentKey = serverBrowser.value;
            var key = prompt("party key", currentKey);
            if (key) {
                window.onbeforeunload = undefined;
                window.location.href = "/?server=" + key;
            }
        }
        // MATHS:
        var lerpAngle = function(value1, value2, amount) {
            var difference = abs(value2 - value1);
            if (difference > pi) {
                if (value1 > value2) {
                    value2 += pi2;
                } else {
                    value1 += pi2;
                }
            }
            var value = value2 + (value1 - value2) * amount;
            if (value >= 0 && value <= pi2) {
                return value;
            }
            return value % pi2;
        }
        ;

        // STORAGE:
        var canStore;
        if (typeof(Storage) !== "undefined") {
            canStore = true;
        }

        function saveVal(name, val) {
            if (canStore) {
                localStorage.setItem(name, val);
            }
        }

        function deleteVal(name) {
            if (canStore) {
                localStorage.removeItem(name);
            }
        }

        function getSavedVal(name) {
            if (canStore) {
                return localStorage.getItem(name);
            }
            return null;
        }

        //Custom add ons
        var mills = {
            place: false,
            placeSpawnPads: false,
            old: {
                x: 0,
                y: 0,
            },
            millDist: 99,
            spawnPadDist: 120
        }
        // GLOBAL VALUES:
        class ez_UI {
            get(id) {
                return getEl(id);
            }
            constructor() {
                this.adCard = this.get("adCard");
                this.adContainer = this.get("ad-container");
                this.promoImg = this.get("promoImg");
                this.promoImageHolder = this.get("promoImgHolder");
                this.wideAdCard = this.get("wideAdCard");
                this.storeButton = this.get("storeButton");
                this.allianceButton = this.get("allianceButton");
                this.chatButton = this.get("chatButton");
                this.enterGame = this.get("enterGame");
                this.altcha_CheckBox = this.get("altcha_checkbox");
                this.partyButton = this.get("partyButton");
                this.joinPartyButton = this.get("joinPartyButton");
                this.settingsButton = this.get("settingsButton");
                this.settingsButtonTitle = this.get("settingsButton").getElementsByTagName('span')[0];
                this.foodDisplay = this.get("foodDisplay");
                this.woodDisplay = this.get("woodDisplay");
                this.stoneDisplay = this.get("stoneDisplay");
                this.scoreDisplay = this.get("scoreDisplay");
                this.killCounter = this.get("killCounter");
                this.menuText = this.get("desktopInstructions");
                this.setupCard = this.get("setupCard");
                this.guideCard = this.get("guideCard");
                this.gameUI = this.get("gameUI");
                this.gameName = this.get("gameName");
                this.mainMenu = this.get("mainMenu");
                this.storeMenu = this.get("storeMenu");
                this.nameInput = this.get("nameInput");
                this.gameCanvas = this.get("gameCanvas");
                this.gameContext = this.get("gameCanvas").getContext("2d");
                this.mapDisplay = this.get("mapDisplay");
                this.mapContext = this.get("mapDisplay").getContext("2d");
                this.shutdownDisplay = this.get("shutdownDisplay");
                this.pingDisplay = this.get("pingDisplay");
                this.loadingText = this.get("loadingText");
                this.diedText = this.get("diedText");
                this.ageText = this.get("ageText");
                this.ageBarBody = this.get("ageBarBody");
                this.allianceMenu = this.get("allianceMenu");
                this.allianceManager = this.get("allianceManager");
                this.leaderboard = this.get("leaderboard")
                this.noticationDisplay = this.get("noticationDisplay");
                this.leaderboardData = this.get("leaderboardData");
                this.actionBar = this.get("actionBar");
                this.playMusic = this.get("playMusic");
                this.upgradeCounter = this.get("upgradeCounter");
                this.chatBox = this.get("chatBox");
                this.altcha = this.get("altcha");
                this.menuCardHolder = this.get("menuCardHolder");
                this.itemInfoHolder = this.get("itemInfoHolder");
                this.upgradeHolder = this.get("upgradeHolder");
                this.allianceHolder = this.get("allianceHolder");
                this.skinColorHolder = this.get("skinColorHolder");
                this.storeHolder = this.get("storeHolder");
                this.chatHolder = this.get("chatHolder");
                this.serverBrowser = this.get("serverBrowser");
                this.nativeResolutionOption = this.get("nativeResolution");
                this.touchControls = this.get("touch-controls-fullscreen");
                this.showPingCheckbox = this.get("showPing");
                this.linksContainer2 = this.get("linksContainer2");
                this.menuContainer = this.get("menuContainer");
            }
        }
        // UIS:
        var FRVR_UI = new ez_UI();
        var adCard = FRVR_UI.adCard;
        var adContainer = FRVR_UI.adContainer;
        var promoImg = FRVR_UI.promoImg;
        var promoImageHolder = FRVR_UI.promoImageHolder;
        var wideAdCard = FRVR_UI.wideAdCard;
        var storeButton = FRVR_UI.storeButton;
        var allianceButton = FRVR_UI.allianceButton;
        var chatButton = FRVR_UI.chatButton;
        var enterGameButton = FRVR_UI.enterGame;
        var altcha_CheckBox = FRVR_UI.altcha_CheckBox;
        var partyButton = FRVR_UI.partyButton;
        var joinPartyButton = FRVR_UI.joinPartyButton;
        var settingsButton = FRVR_UI.settingsButton;
        var settingsButtonTitle = FRVR_UI.settingsButtonTitle;
        var foodDisplay = FRVR_UI.foodDisplay;
        var woodDisplay = FRVR_UI.woodDisplay;
        var stoneDisplay = FRVR_UI.stoneDisplay;
        var scoreDisplay = FRVR_UI.scoreDisplay;
        var killCounter = FRVR_UI.killCounter;
        var menuText = FRVR_UI.menuText;
        var setupCard = FRVR_UI.setupCard;
        var guideCard = FRVR_UI.guideCard;
        var gameUI = FRVR_UI.gameUI;
        var gameName = FRVR_UI.gameName;
        var mainMenu = FRVR_UI.mainMenu;
        var storeMenu = FRVR_UI.storeMenu;
        var nameInput = FRVR_UI.nameInput;
        var gameCanvas = FRVR_UI.gameCanvas;
        var gameContext = FRVR_UI.gameContext;
        var mapDisplay = FRVR_UI.mapDisplay;
        var mapContext = FRVR_UI.mapContext;
        var shutdownDisplay = FRVR_UI.shutdownDisplay;
        var pingDisplay = FRVR_UI.pingDisplay;
        var loadingText = FRVR_UI.loadingText;
        var diedText = FRVR_UI.diedText;
        var ageText = FRVR_UI.ageText;
        var ageBarBody = FRVR_UI.ageBarBody;
        var allianceMenu = FRVR_UI.allianceMenu;
        var allianceManager = FRVR_UI.allianceManager;
        var noticationDisplay = FRVR_UI.noticationDisplay;
        var leaderboard = FRVR_UI.leaderboard
        var leaderboardData = FRVR_UI.leaderboardData;
        var actionBar = FRVR_UI.actionBar;
        var playMusic = FRVR_UI.playMusic;
        var upgradeCounter = FRVR_UI.upgradeCounter;
        var chatBox = FRVR_UI.chatBox;
        var altcha = FRVR_UI.altcha;
        var menuCardHolder = FRVR_UI.menuCardHolder;
        var itemInfoHolder = FRVR_UI.itemInfoHolder;
        var upgradeHolder = FRVR_UI.upgradeHolder;
        var allianceHolder = FRVR_UI.allianceHolder;
        var skinColorHolder = FRVR_UI.skinColorHolder;
        var storeHolder = FRVR_UI.storeHolder;
        var chatHolder = FRVR_UI.chatHolder;
        var serverBrowser = FRVR_UI.serverBrowser;
        var nativeResolutionCheckbox = FRVR_UI.nativeResolutionOption;
        var touchControls = FRVR_UI.touchControls;
        var showPingCheckbox = FRVR_UI.showPingCheckbox;
        var linksContainer2 = FRVR_UI.linksContainer2;
        var menuContainer = FRVR_UI.menuContainer;
        // UI for menus and styles
        class UI {
            constructor() {
                this.content = '';
            }

            append(html) {
                this.content += html;
            }

            Text(text, size = '16px', color = 'white') {
                this.append(`<span style="font-size: ${size}; color: ${color};">${text}</span>`);
            }

            newLine(num = 1) {
                this.append('<br>'.repeat(num));
            }

            static AppendTo(targetId, uiCallback) {
                const target = getEl(targetId);
                if (target) {
                    const htmlui = new UI();
                    uiCallback(htmlui);
                    target.innerHTML += htmlui.content;
                }
            }

            static InnerHtml(targetId, uiCallback) {
                const target = getEl(targetId);
                if (target) {
                    const htmlui = new UI();
                    uiCallback(htmlui);
                    target.innerHTML = htmlui.content;
                }
            }
            static addStyle(id, style) {
                let styleElement = getEl(id);
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = id;
                    document.head.appendChild(styleElement);
                }
                styleElement.textContent = style;
            }
        }
      // Notification
     function showNotification(message, options = {}) {
    const {
        type = 'info',
        duration = 3000,
        image = null,
        end = 'time',
    } = options;

    const notificationId = 'notification-container';
    const maxNotifications = 4;

    UI.addStyle('notification-styles', `
        #${notificationId} {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 300px;
            z-index: 9999;
            pointer-events: none;
            display: flex;
            flex-direction: column-reverse;
        }
        .notification {
            display: flex;
            align-items: center;
            padding: 20px;
            margin-bottom: 10px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            font-family: Arial, sans-serif;
            box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        .notification img {
            width: 40px;
            height: 40px;
            margin-right: 10px;
            border-radius: 5px;
        }
    `);

    let container = document.getElementById(notificationId);
    if (!container) {
        container = document.createElement('div');
        container.id = notificationId;
        document.body.appendChild(container);
    }

    while (container.children.length >= maxNotifications) {
        const oldestNotification = container.firstChild;
        oldestNotification.style.opacity = '0';
        setTimeout(() => oldestNotification.remove(), 500);
    }

    const htmlui = new UI();
    htmlui.append('<div class="notification" style="opacity: 0;">');
    if (image) {
        htmlui.append(`<img src="${image}" alt="Profile">`);
    }
    htmlui.Text(message);
    htmlui.append('</div>');

    const notificationElement = document.createElement('div');
    notificationElement.innerHTML = htmlui.content;
    const notification = notificationElement.firstChild;
    container.appendChild(notification);

    setTimeout(() => {
        notification.style.opacity = '1';
    }, 10);

    if (end === 'time') {
        setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => notification.remove(), 500);
        }, duration);
    } else if (typeof end === 'boolean' && end === false) {
    } else if (typeof end === 'function') {
        const interval = setInterval(() => {
            if (end()) {
                clearInterval(interval);
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500);
            }
        }, 100);
    }
}

        var savedName;
        //
        upgradeHolder.style.top = "50px";
        ageText.style.position = "absolute";
        upgradeCounter.style.top = "125px";
        chatButton.style.display = "none";
        if (location.hostname == "sandbox.moomoo.io") {
            foodDisplay.style.display = "none";
            woodDisplay.style.display = "none";
            stoneDisplay.style.display = "none";
        }
        mapDisplay.width = 300;
        mapDisplay.height = 300;
        // Gay adsRemove
        adCard.remove();
        linksContainer2.remove();
        promoImageHolder.remove();
        wideAdCard.remove();

        // Uhm wow okay menu
        linksContainer2.remove();
        joinPartyButton.remove();
        partyButton.remove();

        menuContainer.remove();
        var moofoll = getSavedVal("moofoll");
        function follmoo() {
            if (!moofoll) {
                moofoll = true;
                saveVal("moofoll", 1);
            }
        }
        //buncha variables
        var useNativeResolution;
        var showPing;
        var pixelDensity = 1;
        var delta, now, lastSent;
        var lastUpdate = Date.now();
        var keys, attackState;
        var ais = [];
        var players = [];
        var alliances = [];
        var gameObjects = [];
        var nearObjs = [];
        var projectiles = [];
        var macro = [];
        var debugStop = false;
        var player, playerSID, tmpObj;
        var waterMult = 1;
        var waterPlus = 0;
        var mouseX = 0;
        var mouseY = 0;
        var camX, camY;
        var tmpDir;
        var skinColor = 0;
        var maxScreenWidth = config.maxScreenWidth;
        var maxScreenHeight = config.maxScreenHeight;
        var screenWidth, screenHeight;
        var inGame = false;
        var game = {
            tick: 0,
            tickQueue: [],
            tickBase: function (set, tick) {
                if (this.tickQueue[this.tick + tick]) {
                    this.tickQueue[this.tick + tick].push(set);
                } else {
                    this.tickQueue[this.tick + tick] = [set];
                }
            },
            tickRate: (1000 / config.serverUpdateRate),
            tickSpeed: 0,
            lastTick: performance.now()
        };
        var enemy = [];
        var nears = [];
        var near;
        var my = {
            reloaded: false,
            waitHit: 0,
            autoAim: false,
            revAim: false,
            ageInsta: true,
            reSync: false,
            bullTick: 0,
            anti0Tick: 0,
            predictSpikes: 0,
            antiSync: false,
            safePrimary: function (tmpObj) {
                return [0, 8].includes(tmpObj.primaryIndex);
            },
            safeSecondary: function (tmpObj) {
                return [10, 11, 14].includes(tmpObj.secondaryIndex);
            },
            lastDir: 0,
            autoPush: false,
            pushData: {},
            millPlacePos: {
                x: 0,
                y: 0
            },
            antiInsta: false,
            stopBreak: false
        };
        var labut = false;
        var ctx = gameCanvas.getContext("2d");
        var hats = store.hats;
        var accessories = store.accessories;
        var outlineColor = "#525252";
        var darkOutlineColor = "#3d3f42";
        var outlineWidth = 5.5;
        var volcano = {
            xof: undefined,
            yof: undefined,
            animationTime: 0,
            land: null,
            lava: null,
            x: config.volcanoLocationX,
            y: config.volcanoLocationY
        };

        // For MainMenu and other
        var AltchaToken = '';
        var mainMenuM = {
            firstLoad: false,
        }
        altchaManager.executeRecaptcha().then((data) => {
            AltchaToken = data;
        });
        altchaManager.fetchServers();

        class AutoBreaker {
            constructor() {
                this.active = false; // Indicates if the auto-breaker system is active
                this.aim = 0; // Current aim direction
                this.priority = [[], [], [], []]; // Priority lists for target objects
                this.target = null; // Stores the closest current target
            }

            objectsHit(aim) {
                let results = [];
                nearObjs.forEach(e => {
                    let dir = Utils.getDirect(e, player, 0, 2);
                    if (e.active && e.type == null && Utils.getDist(player, e, 2, 0) <= items.weapons[this.useHammer(e) ? player.weapons[1] : player.weapons[0]].range + e.scale &&
                        Utils.getAngleDist(dir, aim) <= pi / 2.6) {
                        results.push(e);
                    }
                });
                return results; // Return all hittable objects
            }

            getFilteredPriority() {
                const filteredPriority = this.priority.map(list =>
                                                           list.filter(obj =>
                                                                       obj.active && Utils.getDist(obj, player, 0, 2) <= items.weapons[this.useHammer(obj) ? player.weapons[1] : player.weapons[0]].range + obj.scale
                                                                      )
                                                          );
                return filteredPriority;
            }

            calculateAim() {
                const filteredPriority = this.getFilteredPriority();

                // Loop through priority levels from [0] to [3]
                for (let level = 0; level < filteredPriority.length; level++) {
                    const targets = filteredPriority[level];

                    if (level == 3) {
                        if (enemy.length && near.dist2 <= 600) {
                            this.active = false;
                            return; // Exit early if the condition is met
                        }
                    }

                    if (targets.length > 0) {
                        const special = level == 0;
                        this.processTargets(targets, special);
                        return; // Exit after processing targets
                    }
                }

                // If no targets were processed, deactivate
                this.active = false;
            }

            processTargets(targetObjs, special) {
                if (!targetObjs.length) return; // No targets, no aim

                let maxTargetsHit = 0;
                const checkedAims = new Set(); // To avoid redundant aim checks

                // Optimization: Pre-compute directions for all target objects
                const targetDirections = targetObjs.map(obj => Utils.getDirect(obj, player, 0, 2));

                // Handle multiple targets
                if (targetObjs.length > 1) {
                    // 1. Check pairwise aims (in-between targets)
                    for (let i = 0; i < targetObjs.length; i++) {
                        for (let j = i + 1; j < targetObjs.length; j++) {
                            const aimBetween = (targetDirections[i] + targetDirections[j]) / 2;

                            // Avoid redundant checks
                            if (checkedAims.has(aimBetween)) continue;
                            checkedAims.add(aimBetween);

                            const validHits = this.objectsHit(aimBetween).filter(hit => targetObjs.includes(hit)); // Filter valid hits

                            if (validHits.length > maxTargetsHit) {
                                this.aim = aimBetween;
                                this.active = true;
                                maxTargetsHit = validHits.length;

                                this.target = validHits[0]; // Update target
                                if (maxTargetsHit === targetObjs.length) return;
                            }
                        }
                    }

                    // 2. Check direct aims at each target
                    for (let i = 0; i < targetObjs.length; i++) {
                        const aimDirect = targetDirections[i];

                        // Avoid redundant checks
                        if (checkedAims.has(aimDirect)) continue;
                        checkedAims.add(aimDirect);

                        const validHits = this.objectsHit(aimDirect).filter(hit => targetObjs.includes(hit)); // Filter valid hits

                        if (validHits.length > maxTargetsHit) {
                            this.aim = aimDirect;
                            this.active = true;
                            maxTargetsHit = validHits.length;

                            this.target = validHits[0]; // Update target
                            if (maxTargetsHit === targetObjs.length) return;
                        }
                    }
                }

                // Handle single target case or fallback if no valid multi-target aim is found
                if (targetObjs.length === 1 || maxTargetsHit === 0) {
                    const target = targetObjs[0];
                    const aimDirect = targetDirections[0]; // Already computed for first target
                    let avoidObjs = nearObjs.filter(obj => !targetObjs.includes(obj) && obj.active && obj.isTeamObject(player) && Utils.getDist(obj, player, 0, 2) <= 300);

                    // If avoidObjs exist, try safer angles
                    if (avoidObjs.length) {
                        let hits = this.objectsHit(aimDirect);
                        if (!avoidObjs.some(obj => hits.includes(obj))) {
                            this.aim = aimDirect;
                            this.target = target;
                            this.active = true;
                            return;
                        }
                        const safeAngles = [pi / 2.6 / 3, pi / 2.6 / 2, pi / 2.6 - 0.1];
                        for (let safeAngle of safeAngles) {
                            const saferAims = [aimDirect - safeAngle, aimDirect + safeAngle];
                            for (let saferAim of saferAims) {
                                const hitObjs = this.objectsHit(saferAim)
                                //Check if it avoids avoidObjs and hits the target
                                if (hitObjs.includes(target) && !avoidObjs.some(obj => hitObjs.includes(obj))) {
                                    this.aim = saferAim;
                                    this.target = target; // Update target
                                    this.active = true;
                                    return;
                                }
                            }
                        }
                        this.aim = aimDirect;
                        this.target = target;
                        this.active = true;
                        return;
                    } else {
                        this.aim = aimDirect;
                        this.target = target;
                        this.active = true;
                        return;
                    }
                }
            }

            useHammer(object) {
                if (/*isC("hammerBreakerOptimisation").checked && */player.weapons[1] == 10) {
                    if (object) {
                        if (object.health <= items.weapons[player.weapons[0]].dmg && objectManager.canHit(player, object, player.weapons[0]) && ![5, 8].includes(player.weapons[0])) return false;
                    }
                    return true;
                }
                return false;
            }
        }



        // ASSIGN CLASSES:
        var aiManager = new AiManager(ais, AI, players, items, null, config, Utils);
        var objectManager = new ObjectManager(GameObject, gameObjects, Utils, config);
        var projectileManager = new ProjectileManager(Projectile, projectiles, players, ais, objectManager, items, config, Utils);
        var autoBreak = new AutoBreaker();

        // FIND OBJECTS BY ID/SID:
        function findID(tmpObj, tmp) {
            return tmpObj.find((THIS) => THIS.id == tmp);
        }

        function findSID(tmpObj, tmp) {
            return tmpObj.find((THIS) => THIS.sid == tmp);
        }

        function findPlayerByID(id) {
            return findID(players, id);
        }

        function findPlayerBySID(sid) {
            return findSID(players, sid);
        }

        function findAIBySID(sid) {
            return findSID(ais, sid);
        }

        function findObjectBySid(sid) {
            return findSID(gameObjects, sid);
        }

        function findProjectileBySid(sid) {
            return findSID(gameObjects, sid);
        }

        // SET INIT DATA:
        function setInitData(data) {
            alliances = data.teams;
        }

        // ON LOAD:
        var inWindow = true;
        var didLoad = false;
        window.onblur = function() {
            inWindow = false;
        };
        window.onfocus = function() {
            inWindow = true;
            if (player && player.alive) {
                resetMoveDir();
            }
        };
        window.onload = function() {
            didLoad = true;
        };
        gameCanvas.oncontextmenu = function() {
            return false;
        };

        function disconnect(reason) {
            connected = false;
            io.close();
            showLoadingText(reason);
        }

        function showLoadingText(text) {
            mainMenu.style.display = "block";
            gameUI.style.display = "none";
            menuCardHolder.style.display = "none";
            diedText.style.display = "none";
            loadingText.style.display = "block";
            loadingText.innerHTML = text +
                "<a href='javascript:window.location.href=window.location.href' class='ytLink'>reload</a>";
        }

        // BUTTON EVENTS:
        function bindEvents() {
            joinPartyButton.onclick = Utils.checkTrusted(function() {
                setTimeout(function() {
                    joinParty();
                }, 10);
            });
            Utils.hookTouchEvents(joinPartyButton);
            settingsButton.onclick = Utils.checkTrusted(function() {
                toggleSettings();
            });
            Utils.hookTouchEvents(settingsButton);
            allianceButton.onclick = Utils.checkTrusted(function() {
                toggleAllianceMenu();
            });
            Utils.hookTouchEvents(allianceButton);
            storeButton.onclick = Utils.checkTrusted(function() {
                toggleStoreMenu();
            });
            Utils.hookTouchEvents(storeButton);
            chatButton.onclick = Utils.checkTrusted(function() {
                toggleChat();
            });
            Utils.hookTouchEvents(chatButton);
            mapDisplay.onclick = Utils.checkTrusted(function() {
                sendMapPing();
            });
            Utils.hookTouchEvents(mapDisplay);
        }


        // SHOW ALLIANCE MENU:
        var allianceNotifications = [];
        var alliancePlayers = [];

        function allianceNotification(sid, name) {
            allianceNotifications.push({
                sid: sid,
                name: name
            });
            updateNotifications();
        }

        function updateNotifications() {
            if (allianceNotifications[0]) {
                var tmpN = allianceNotifications[0];
                Utils.removeAllChildren(noticationDisplay);
                noticationDisplay.style.display = "block";
                Utils.generateElement({
                    class: "notificationText",
                    text: tmpN.name,
                    parent: noticationDisplay
                });
                Utils.generateElement({
                    class: "notifButton",
                    html: "<i class='material-icons' style='font-size:28px;color:#cc5151;'>&#xE14C;</i>",
                    parent: noticationDisplay,
                    onclick: function() {
                        aJoinReq(0);
                    },
                    hookTouch: true
                });
                Utils.generateElement({
                    class: "notifButton",
                    html: "<i class='material-icons' style='font-size:28px;color:#8ecc51;'>&#xE876;</i>",
                    parent: noticationDisplay,
                    onclick: function() {
                        aJoinReq(1);
                    },
                    hookTouch: true
                });
            } else {
                noticationDisplay.style.display = "none";
            }
        }

        function addAlliance(data) {
            alliances.push(data);
            if (allianceMenu.style.display == "block") {
                showAllianceMenu();
            }
        }

        function setPlayerTeam(team, isOwner) {
            if (player) {
                console.log(team);
                player.team = team;
                player.isOwner = isOwner;
                if (allianceMenu.style.display == "block") {
                    showAllianceMenu();
                }
            }
        }

        function setAlliancePlayers(data) {
            alliancePlayers = data;
            if (allianceMenu.style.display == "block") {
                showAllianceMenu();
            }
        }

        function deleteAlliance(sid) {
            for (let i = alliances.length - 1; i >= 0; i--) {
                if (alliances[i].sid == sid) {
                    alliances.splice(i, 1);
                }
            }
            if (allianceMenu.style.display == "block") {
                showAllianceMenu();
            }
        }

        function toggleAllianceMenu() {
            resetMoveDir();
            if (allianceMenu.style.display != "block") {
                showAllianceMenu();
            } else {
                allianceMenu.style.display = "none";
            }
        }

        function showAllianceMenu() {
            if (player && player.alive) {
                closeChat();
                storeMenu.style.display = "none";
                allianceMenu.style.display = "block";
                Utils.removeAllChildren(allianceHolder);
                if (player.team) {
                    for (let i = 0; i < alliancePlayers.length; i += 2) {
                        (function(i) {
                            var tmp = Utils.generateElement({
                                class: "allianceItem",
                                style: "color:" + (alliancePlayers[i] == player.sid ? "#fff" : "rgba(255,255,255,0.6)"),
                                text: alliancePlayers[i + 1],
                                parent: allianceHolder
                            });
                            if (player.isOwner && alliancePlayers[i] != player.sid) {
                                Utils.generateElement({
                                    class: "joinAlBtn",
                                    text: "Kick",
                                    onclick: function() {
                                        kickFromClan(alliancePlayers[i]);
                                    },
                                    hookTouch: true,
                                    parent: tmp
                                });
                            }
                        })(i);
                    }
                } else {
                    if (alliances.length) {
                        for (let i = 0; i < alliances.length; ++i) {
                            (function(i) {
                                var tmp = Utils.generateElement({
                                    class: "allianceItem",
                                    style: "color:" + (alliances[i].sid == player.team ? "#fff" : "rgba(255,255,255,0.6)"),
                                    text: alliances[i].sid,
                                    parent: allianceHolder
                                });
                                Utils.generateElement({
                                    class: "joinAlBtn",
                                    text: "Join",
                                    onclick: function() {
                                        sendJoin(i);
                                    },
                                    hookTouch: true,
                                    parent: tmp
                                });
                            })(i);
                        }
                    } else {
                        Utils.generateElement({
                            class: "allianceItem",
                            text: "No Tribes Yet",
                            parent: allianceHolder
                        });
                    }
                }
                Utils.removeAllChildren(allianceManager);
                if (player.team) {
                    Utils.generateElement({
                        class: "allianceButtonM",
                        style: "width: 360px",
                        text: player.isOwner ? "Delete Tribe" : "Leave Tribe",
                        onclick: function() {
                            leaveAlliance()
                        },
                        hookTouch: true,
                        parent: allianceManager
                    });
                } else {
                    Utils.generateElement({
                        tag: "input",
                        type: "text",
                        id: "allianceInput",
                        maxLength: 7,
                        placeholder: "unique name",
                        ontouchstart: function(ev) {
                            ev.preventDefault();
                            var newValue = prompt("unique name", ev.currentTarget.value);
                            ev.currentTarget.value = newValue.slice(0, 7);
                        },
                        parent: allianceManager
                    });
                    Utils.generateElement({
                        tag: "div",
                        class: "allianceButtonM",
                        style: "width: 140px;",
                        text: "Create",
                        onclick: function() {
                            createAlliance();
                        },
                        hookTouch: true,
                        parent: allianceManager
                    });
                }
            }
        }

        function aJoinReq(join) {
            io.send("ajoin_req", "P", allianceNotifications[0].sid, join);
            allianceNotifications.splice(0, 1);
            updateNotifications();
        }

        function kickFromClan(sid) {
            io.send("kick_clan", "Q", sid);
        }

        function sendJoin(index) {
            io.send("join_clan", "b", alliances[index].sid);
        }

        function createAlliance() {
            io.send("create_clan", "L", getEl("allianceInput").value);
        }

        function leaveAlliance() {
            allianceNotifications = [];
            updateNotifications();
            io.send("leave_clan", "N");
        }


        // MINIMAP:
        var lastDeath;
        var minimapData;
        var mapMarker;
        var mapPings = [];
        var tmpPing;

        function MapPing() {
            this.init = function(x, y) {
                this.scale = 0;
                this.x = x;
                this.y = y;
                this.active = true;
            };
            this.update = function(ctxt, delta) {
                if (this.active) {
                    this.scale += 0.05 * delta;
                    if (this.scale >= config.mapPingScale) {
                        this.active = false;
                    } else {
                        ctxt.globalAlpha = (1 - max(0, this.scale / config.mapPingScale));
                        ctxt.beginPath();
                        ctxt.arc((this.x / config.mapScale) * mapDisplay.width, (this.y / config.mapScale) *
                                 mapDisplay.width, this.scale, 0, pi2);
                        ctxt.stroke();
                    }
                }
            };
        }

        function pingMap(x, y) {
            for (let i = 0; i < mapPings.length; ++i) {
                if (!mapPings[i].active) {
                    tmpPing = mapPings[i];
                    break;
                }
            }
            if (!tmpPing) {
                tmpPing = new MapPing();
                mapPings.push(tmpPing);
            }
            tmpPing.init(x, y);
        }

        function updateMapMarker() {
            if (!mapMarker) {
                mapMarker = {};
            }
            mapMarker.x = player.x;
            mapMarker.y = player.y;
        }

        function updateMinimap(data) {
            minimapData = data;
        }

        function renderMinimap(delta) {
            if (player && player.alive) {
                mapContext.clearRect(0, 0, mapDisplay.width, mapDisplay.height);

                // RENDER PINGS:
                mapContext.strokeStyle = "#fff";
                mapContext.lineWidth = 4;
                for (let i = 0; i < mapPings.length; ++i) {
                    tmpPing = mapPings[i];
                    tmpPing.update(mapContext, delta);
                }

                // RENDER PLAYERS:
                mapContext.globalAlpha = 1;
                mapContext.fillStyle = "#fff";
                renderCircle((player.x / config.mapScale) * mapDisplay.width,
                             (player.y / config.mapScale) * mapDisplay.height, 7, mapContext, true);
                mapContext.fillStyle = "rgba(255,255,255,0.35)";
                if (player.team && minimapData) {
                    for (let i = 0; i < minimapData.length;) {
                        renderCircle((minimapData[i] / config.mapScale) * mapDisplay.width,
                                     (minimapData[i + 1] / config.mapScale) * mapDisplay.height, 7, mapContext, true);
                        i += 2;
                    }
                }

                // DEATH LOCATION:
                if (lastDeath) {
                    mapContext.fillStyle = "#fc5553";
                    mapContext.font = "34px Hammersmith One";
                    mapContext.textBaseline = "middle";
                    mapContext.textAlign = "center";
                    mapContext.fillText("x", (lastDeath.x / config.mapScale) * mapDisplay.width,
                                        (lastDeath.y / config.mapScale) * mapDisplay.height);
                }

                // MAP MARKER:
                if (mapMarker) {
                    mapContext.fillStyle = "#fff";
                    mapContext.font = "34px Hammersmith One";
                    mapContext.textBaseline = "middle";
                    mapContext.textAlign = "center";
                    mapContext.fillText("x", (mapMarker.x / config.mapScale) * mapDisplay.width,
                                        (mapMarker.y / config.mapScale) * mapDisplay.height);
                }
            }
        }

        // STORE MENU:
        var currentStoreIndex = 0;
        var playerItems = {};

        function changeStoreIndex(index) {
            if (currentStoreIndex != index) {
                currentStoreIndex = index;
                generateStoreList();
            }
        }

        function toggleStoreMenu() {
            if (storeMenu.style.display != "block") {
                storeMenu.style.display = "block";
                allianceMenu.style.display = "none";
                closeChat();
                generateStoreList();
            } else {
                storeMenu.style.display = "none";
            }
        }

        function updateStoreItems(type, id, index) {
            if (index) {
                if (!type) {
                    player.tails[id] = 1;
                } else {
                    player.tailIndex = id;
                }
            } else {
                if (!type) {
                    player.skins[id] = 1;
                } else {
                    player.skinIndex = id;
                }
            }
            if (storeMenu.style.display == "block") {
                generateStoreList();
            }
        }

        function generateStoreList() {
            if (player) {
                Utils.removeAllChildren(storeHolder);
                var index = currentStoreIndex;
                var tmpArray = index ? accessories : hats;
                for (let i = 0; i < tmpArray.length; ++i) {
                    if (!tmpArray[i].dontSell) {
                        (function(i) {
                            var tmp = Utils.generateElement({
                                id: "storeDisplay" + i,
                                class: "storeItem",
                                parent: storeHolder
                            });
                            Utils.hookTouchEvents(tmp, true);
                            Utils.generateElement({
                                tag: "img",
                                class: "hatPreview",
                                src: "../img/" + (index ? "accessories/access_" : "hats/hat_") + tmpArray[i].id + (tmpArray[i].topSprite ? "_p" : "") + ".png",
                                parent: tmp
                            });
                            Utils.generateElement({
                                tag: "span",
                                text: tmpArray[i].name,
                                parent: tmp
                            });
                            if (index ? (!player.tails[tmpArray[i].id]) : (!player.skins[tmpArray[i].id])) {
                                Utils.generateElement({
                                    class: "joinAlBtn",
                                    style: "margin-top: 5px",
                                    text: "Buy",
                                    onclick: function() {
                                        storeBuy(tmpArray[i].id, index);
                                    },
                                    hookTouch: true,
                                    parent: tmp
                                });
                                Utils.generateElement({
                                    tag: "span",
                                    class: "itemPrice",
                                    text: tmpArray[i].price,
                                    parent: tmp
                                })
                            } else if ((index ? player.tailIndex : player.skinIndex) == tmpArray[i].id) {
                                Utils.generateElement({
                                    class: "joinAlBtn",
                                    style: "margin-top: 5px",
                                    text: "Unequip",
                                    onclick: function() {
                                        storeEquip(0, index);
                                    },
                                    hookTouch: true,
                                    parent: tmp
                                });
                            } else {
                                Utils.generateElement({
                                    class: "joinAlBtn",
                                    style: "margin-top: 5px",
                                    text: "Equip",
                                    onclick: function() {
                                        storeEquip(tmpArray[i].id, index);
                                    },
                                    hookTouch: true,
                                    parent: tmp
                                });
                            }
                        })(i);
                    }
                }
            }
        }

        function storeEquip(id, index) {
            io.send("hatAccs", "c", 0, id, index);
        }

        function storeBuy(id, index) {
            io.send("hatAccs", "c", 1, id, index);
        }

        // HIDE WINDOWS:
        function hideAllWindows() {
            storeMenu.style.display = "none";
            allianceMenu.style.display = "none";
            closeChat();
        }

        // PREPARE UI:
        function prepareUI() {

            // NATIVE RESOLUTION:
            var savedNativeValue = getSavedVal("native_resolution");
            if (!savedNativeValue) {
                setUseNativeResolution(typeof cordova !== "undefined"); // Only default to native if on mobile
            } else {
                setUseNativeResolution(savedNativeValue == "true");
            }

            // SHOW PING:
            showPing = getSavedVal("show_ping") == "true";
            pingDisplay.hidden = !showPing;


            // ACTION BAR:
            Utils.removeAllChildren(actionBar);
            for (let i = 0; i < (items.weapons.length + items.list.length); ++i) {
                (function(i) {
                    Utils.generateElement({
                        id: "actionBarItem" + i,
                        class: "actionBarItem",
                        style: "display:none",
                        parent: actionBar
                    });
                })(i);
            }
            for (let i = 0; i < (items.list.length + items.weapons.length); ++i) {
                (function(i) {
                    var tmpCanvas = document.createElement('canvas');
                    tmpCanvas.width = tmpCanvas.height = 66;
                    var tmpContext = tmpCanvas.getContext('2d');
                    tmpContext.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
                    tmpContext.imageSmoothingEnabled = false;
                    tmpContext.webkitImageSmoothingEnabled = false;
                    tmpContext.mozImageSmoothingEnabled = false;
                    if (items.weapons[i]) {
                        tmpContext.rotate(pi*1.25);
                        var tmpSprite = new Image();
                        toolSprites[items.weapons[i].src] = tmpSprite;
                        tmpSprite.onload = function() {
                            this.isLoaded = true;
                            var tmpPad = 1 / (this.height / this.width);
                            var tmpMlt = (items.weapons[i].iPad || 1);
                            tmpContext.drawImage(this, -(tmpCanvas.width * tmpMlt * config.iconPad * tmpPad) / 2, -(tmpCanvas.height * tmpMlt * config.iconPad) / 2,
                                                 tmpCanvas.width * tmpMlt * tmpPad * config.iconPad, tmpCanvas.height * tmpMlt * config.iconPad);
                            tmpContext.fillStyle = "rgba(0, 0, 70, 0.1)";
                            tmpContext.globalCompositeOperation = "source-atop";
                            tmpContext.fillRect(-tmpCanvas.width / 2, -tmpCanvas.height / 2, tmpCanvas.width, tmpCanvas.height);
                            getEl('actionBarItem' + i).style.backgroundImage = "url(" + tmpCanvas.toDataURL() + ")";
                        };
                        tmpSprite.src = ".././img/weapons/" + items.weapons[i].src + ".png";
                        var tmpUnit = getEl('actionBarItem' + i);

                        tmpUnit.onclick = Utils.checkTrusted(function() {
                            selectWeapon(player.weapons[items.weapons[i].type]);
                        });
                        Utils.hookTouchEvents(tmpUnit);
                    } else {
                        let tmpSprite = getItemSprite(items.list[i - items.weapons.length], true);
                        var tmpScale = min(tmpCanvas.width - config.iconPadding, tmpSprite.width);
                        tmpContext.globalAlpha = 1;
                        tmpContext.drawImage(tmpSprite, -tmpScale / 2, -tmpScale / 2, tmpScale, tmpScale);
                        tmpContext.fillStyle = "rgba(0, 0, 70, 0.1)";
                        tmpContext.globalCompositeOperation = "source-atop";
                        tmpContext.fillRect(-tmpScale / 2, -tmpScale / 2, tmpScale, tmpScale);
                        getEl('actionBarItem' + i).style.backgroundImage = "url(" + tmpCanvas.toDataURL() + ")";
                        let tmpUnit = getEl('actionBarItem' + i);
                        tmpUnit.onclick = Utils.checkTrusted(function() {
                            selectToBuild(i - items.weapons.length);
                        });
                        Utils.hookTouchEvents(tmpUnit);
                    }
                })(i);
            }

            // MOBILE NAME INPUT:
            nameInput.ontouchstart = Utils.checkTrusted(function(e) {
                e.preventDefault();
                var newValue = prompt("enter name", e.currentTarget.value);
                e.currentTarget.value = newValue.slice(0, 15);
            });

            // SETTINGS:
            nativeResolutionCheckbox.checked = useNativeResolution;
            nativeResolutionCheckbox.onchange = Utils.checkTrusted(function(e) {
                setUseNativeResolution(e.target.checked);
            });
            showPingCheckbox.checked = showPing;
            showPingCheckbox.onchange = Utils.checkTrusted(function(e) {
                showPing = showPingCheckbox.checked;
                pingDisplay.hidden = !showPing;
                saveVal("show_ping", showPing ? "true" : "false");
            });
        }

        function updateItems(data, wpn) {
            if (data) {
                if (wpn) player.weapons = data;
                else player.items = data;
            }
            for (let i = 0; i < items.list.length; ++i) {
                var tmpI = (items.weapons.length + i);
                getEl("actionBarItem" + tmpI).style.display = (player.items.indexOf(items.list[i].id) >= 0) ? "inline-block" : "none";
            }
            for (let i = 0; i < items.weapons.length; ++i) {
                getEl("actionBarItem" + i).style.display =
                    (player.weapons[items.weapons[i].type] == items.weapons[i].id) ? "inline-block" : "none";
            }
        }

        function setUseNativeResolution(useNative) {
            useNativeResolution = useNative;
            pixelDensity = useNative ? (window.devicePixelRatio || 1) : 1;
            nativeResolutionCheckbox.checked = useNative;
            saveVal("native_resolution", useNative.toString());
            resize();
        }

        function updateGuide() {

        }

        // SETTINGS STUFF:
        function toggleSettings() {
            if (guideCard.classList.contains("showing")) {
                guideCard.classList.remove("showing");
                settingsButtonTitle.innerText = "Settings";
            } else {
                guideCard.classList.add("showing");
                settingsButtonTitle.innerText = "Close";
            }
        }



        function toggleChat() {
            if (chatHolder.style.display == "block") {
                if (chatBox.value) {
                    sendChat(chatBox.value);
                }
                closeChat();
            } else {
                storeMenu.style.display = "none";
                allianceMenu.style.display = "none";
                chatHolder.style.display = "block";
                chatBox.focus();
                resetMoveDir();
            }
            chatBox.value = "";
        }

        function sendChat(message) {
            io.send("chat", "6", message.slice(0, 30));
        }

        function closeChat() {
            chatBox.value = "";
            chatHolder.style.display = "none";
        }

        // SEND MESSAGE:
        var profanityList = ["cunt", "whore", "fuck", "shit", "faggot", "nigger", "nigga", "dick", "vagina", "minge", "cock", "rape", "cum", "sex", "tits", "penis", "clit", "pussy", "meatcurtain", "jizz", "prune", "douche", "wanker", "damn", "bitch", "dick", "fag", "bastard"];

        function checkProfanityString(text) {
            var tmpString;
            for (let i = 0; i < profanityList.length; ++i) {
                if (text.indexOf(profanityList[i]) > -1) {
                    tmpString = "";
                    for (var y = 0; y < profanityList[i].length; ++y) {
                        tmpString += tmpString.length ? "o" : "M";
                    }
                    var re = new RegExp(profanityList[i], 'g');
                    text = text.replace(re, tmpString);
                }
            }
            return text;
        }

        function receiveChat(sid, message) {
            var tmpPlayer = findPlayerBySID(sid);
            if (tmpPlayer) {
                tmpPlayer.chatMessage = checkProfanityString(message);
                tmpPlayer.chatCountdown = config.chatCountdown;
            }
        }

        // RESIZE:
        window.addEventListener('resize', Utils.checkTrusted(resize));

        function resize() {
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;
            var scaleFillNative = max(screenWidth / maxScreenWidth, screenHeight / maxScreenHeight) * pixelDensity;
            gameCanvas.width = screenWidth * pixelDensity;
            gameCanvas.height = screenHeight * pixelDensity;
            gameCanvas.style.width = screenWidth + "px";
            gameCanvas.style.height = screenHeight + "px";
            ctx.setTransform(
                scaleFillNative, 0,
                0, scaleFillNative,
                (screenWidth * pixelDensity - (maxScreenWidth * scaleFillNative)) / 2,
                (screenHeight * pixelDensity - (maxScreenHeight * scaleFillNative)) / 2
            );
        }
        resize();




        // MOUSE INPUT:
        touchControls.addEventListener('mousemove', gameInput, false);

        function gameInput(e) {
            e.preventDefault();
            e.stopPropagation();

            mouseX = e.clientX;
            mouseY = e.clientY;
        }
        var clicks = {
            left: false,
            right: false,
            middle: false
        }
        touchControls.addEventListener('mousedown', mouseDown, false);

        function mouseDown(e) {

            if (attackState != 1) {
                attackState = 1;
                if (e.button == 0) {
                    clicks.left = true;
                } else if (e.button == 1) {
                    clicks.middle = true;
                } else if (e.button == 2) {
                    clicks.right = true;
                }
            }
        }
        touchControls.addEventListener('mouseup', mouseUp, false);

        function mouseUp(e) {

            if (attackState != 0) {
                attackState = 0;
                if (e.button == 0) {
                    clicks.left = false;
                } else if (e.button == 1) {
                    clicks.middle = false;
                } else if (e.button == 2) {
                    clicks.right = false;
                }
            }
        }

        // INPUT Utils:
        function getMoveDir() {
            var dx = 0;
            var dy = 0;
            for (var key in moveKeys) {
                var tmpDir = moveKeys[key];
                dx += !!keys[key] * tmpDir[0];
                dy += !!keys[key] * tmpDir[1];
            }

            return (dx == 0 && dy == 0) ? undefined : Utils.fixTo(atan2(dy, dx), 2);
        }
        var lastDir;

        function getAttackDir() {
            if (!player) return 0;
            if (!player.lockDir) {
                lastDir = atan2((mouseY + camY - player.y) - (screenHeight / 2), (mouseX + camX - player.x) - (screenWidth / 2));
            }
            return Utils.fixTo(lastDir || 0, 2);
        }

        var moveKeys = {
            87: [0, -1],
            38: [0, -1],
            83: [0, 1],
            40: [0, 1],
            65: [-1, 0],
            37: [-1, 0],
            68: [1, 0],
            39: [1, 0]
        };

        function resetMoveDir() {
            keys = {};
            io.send("reset", "e");
        }

        function keysActive() {
            return (allianceMenu.style.display != "block" &&
                    chatHolder.style.display != "block");
        }


        function keyDown(event) {
            let keyNum = event.which || event.keyCode || 0;
            if (player && player.alive && keysActive()) {
                if (!keys[keyNum]) {
                    keys[keyNum] = 1;
                    macro[event.key] = 1;
                    if (keyNum == 27) {
                        const menu = document.getElementById('modmenus');
                        if (menu.classList.contains('open')) {
                            menu.classList.add('closed');
                            menu.classList.remove('open');
                            setTimeout(() => {
                                menu.style.display = 'none';
                            }, 400);
                        } else {
                            menu.classList.add('open');
                            menu.classList.remove('closed');
                            menu.style.display = 'block';
                            setTimeout(() => {
                                document.getElementById('modmenus-sidebar').style.opacity = 1;
                            }, 400);
                        }
                    } else if (keyNum == 69) {
                        sendAutoGather(1);
                    } else if (keyNum == 67) {
                        updateMapMarker();
                    } else if (player.weapons[keyNum - 49] != undefined) {
                        selectToBuild(player.weapons[keyNum - 49], true);
                        player.holdWeapon = player.weapons[keyNum - 49];
                    } else if (player.items[keyNum - 49 - player.weapons.length] != undefined) {
                        selectToBuild(player.items[keyNum - 49 - player.weapons.length]);
                    } else if (event.key == "m") {
                        mills.placeSpawnPads = !mills.placeSpawnPads;
                        Cplace(player.getItemType(20), 0, pi*1.5, pi_2, getMoveDir()||0)
                        mills.old = {
                            x: player.x2,
                            y: player.y2
                        }
                    } else if (event.key == "z") {
                        mills.place = !mills.place;
                        let placeAngle = player.items[4] == 16 ? 1.4 : 1.23456789
                        Cplace(3, -placeAngle, placeAngle, placeAngle, (getMoveDir()||0) + pi)
                        mills.old = {
                            x: player.x2,
                            y: player.y2
                        }
                    } else if (event.key == "Z") {
                        typeof window.debug == "function" && window.debug();
                    } else if (keyNum == 32) {
                        attackState = 1;
                        sendAtckState();
                    } else if (event.key == ",") {
                        player.sync = true;
                        //  sendChat(getEl("syncChat").value)
                    } else if (keyNum == 16) {
                        debugStop = true;
                        setTimeout(() => {
                            debugStop = false;
                        }, 10000)
                    }
                }
            }
        }
        window.addEventListener('keydown', Utils.checkTrusted(keyDown));

        function keyUp(event) {
            if (player && player.alive) {
                let keyNum = event.which || event.keyCode || 0;
                if (keyNum == 13) {
                    //toggleMenuChat();
                    player.moveDir = undefined;
                } else if (keysActive()) {
                    if (keys[keyNum]) {
                        keys[keyNum] = 0;
                        macro[event.key] = 0;
                        if (event.key == ",") {
                            player.sync = false;
                        } else if (event.key == "C") {
                            // toggleSong();
                        } else if (keyNum == 32) {
                            attackState = 0;
                            sendAtckState();
                        }
                    }
                }
            }
        }
        window.addEventListener('keyup', Utils.checkTrusted(keyUp));

        function sendAtckState() {
            if (player && player.alive) {
                io.send("attack", "F", attackState, (player.buildIndex >= 0 ? getAttackDir() : null));
            }
        }
        var lastMoveDir = undefined;

        function sendMoveDir() {
            var newMoveDir = getMoveDir();
            if (lastMoveDir == undefined || newMoveDir == undefined || abs(newMoveDir - lastMoveDir) > 0.3) {
                io.send("move", "33", newMoveDir);
                lastMoveDir = newMoveDir;
            }
        }

        function sendLockDir() {
            player.lockDir = player.lockDir ? 0 : 1;
            io.send("gather", "K", 0);
        }

        function sendMapPing() {
            io.send("S", 1);
        }
        var autoGathering = false;
        function sendAutoGather(debug) {
            io.send("gather", "K", 1);
            if (!debug) autoGathering = !autoGathering;
        }

        function selectToBuild(index, wpn) {
            io.send("select", "z", index, wpn);
        }

        // ENTER GAME:
        function enterGame() {
            saveVal("moo_name", nameInput.value);
            if (!inGame && socketReady()) {
                inGame = true;
                showLoadingText("Loading...");
                io.send("spawn", "M", {
                    name: tempo_name,
                    moofoll: moofoll,
                    skin: skinColor
                });
            }
        }

        // SETUP GAME:
        var firstSetup = true;

        function setupGame(yourSID) {
            loadingText.style.display = "none";
            menuCardHolder.style.display = "block";
            mainMenu.style.display = "none";
            tempo_container.style.display = "none";
            mainMenuM.firstLoad = true;
            keys = {};
            playerSID = yourSID;
            attackState = 0;
            inGame = true;
            if (firstSetup) {
                firstSetup = false;
                gameObjects.length = 0;
            }
        }

        // SHOW ANIM TEXT:
        function showText(x, y, value, type, color = "#fff") {
            let scale = 35;

            if (typeof value === "number") {
                if (type === -1) {
                    color = "#ee5551";
                    scale = 40;
                } else {
                    let val = abs(value);
                    color = value >= 0 ? "#cc5151" : "#8ecc51";
                    scale = max(40, val);
                    value = val;
                }
            }
            textManager.addText(x, y, value, type, scale, color, textManager.texts.length);
        }


        // KILL PLAYER:
        var deathTextScale = 99999;

        function killPlayer() {
            inGame = false;
            gameUI.style.display = "none";
            hideAllWindows();
            lastDeath = {
                x: player.x,
                y: player.y
            };
            loadingText.style.display = "none";
            diedText.style.display = "block";
            diedText.style.fontSize = "0px";
            deathTextScale = 0;
            let deathSS = getEl("deaths");
            let currentDeaths = parseInt(deathSS.innerText, 10);
            let deathss = currentDeaths + 1;
            deathSS.innerText = deathss.toString();
            setTimeout(function() {
                menuCardHolder.style.display = "block";
                mainMenu.style.display = "block";
                diedText.style.display = "none";
                tempo_container.style.display = "block";
            }, config.deathFadeout);
        }

        // KILL ALL OBJECTS BY A PLAYER:
        function killObjects(sid) {
            if (player) objectManager.removeAllItems(sid);
        }

        // KILL OBJECT:
        function killObject(sid) {
            objectManager.disableBySid(sid);
        }

        // UPDATE SCORE DISPLAY:
        function updateStatusDisplay() {
            scoreDisplay.innerText = player.points;
            foodDisplay.innerText = player.food;;
            woodDisplay.innerText = player.wood;
            stoneDisplay.innerText = player.stone;
            killCounter.innerText = player.kills;
        }

        // ICONS:
        var iconSprites = {};
        var icons = ["crown", "skull"];

        function loadIcons() {
            for (let i = 0; i < icons.length; ++i) {
                var tmpSprite = new Image();
                tmpSprite.onload = function() {
                    this.isLoaded = true;
                };
                tmpSprite.src = ".././img/icons/" + icons[i] + ".png";
                iconSprites[icons[i]] = tmpSprite;
            }
        }

        // UPDATE UPGRADES:
        var tmpList = [];

        function updateUpgrades(points, age) {
            player.upgradePoints = points;
            player.upgrAge = age;
            if (points > 0) {
                tmpList.length = 0;
                Utils.removeAllChildren(upgradeHolder);
                for (let i = 0; i < items.weapons.length; ++i) {
                    if (items.weapons[i].age == age && (items.weapons[i].pre == undefined || player.weapons.indexOf(items.weapons[i].pre) >= 0)) {
                        var e = Utils.generateElement({
                            id: "upgradeItem" + i,
                            class: "actionBarItem",
                            parent: upgradeHolder
                        });
                        e.style.backgroundImage = getEl("actionBarItem" + i).style.backgroundImage;
                        tmpList.push(i);
                    }
                }
                for (let i = 0; i < items.list.length; ++i) {
                    if (items.list[i].age == age && (items.list[i].pre == undefined || player.items.indexOf(items.list[i].pre) >= 0)) {
                        var tmpI = (items.weapons.length + i);
                        let e = Utils.generateElement({
                            id: "upgradeItem" + tmpI,
                            class: "actionBarItem",
                            parent: upgradeHolder
                        });
                        e.style.backgroundImage = getEl("actionBarItem" + tmpI).style.backgroundImage;
                        tmpList.push(tmpI);
                    }
                }
                for (let i = 0; i < tmpList.length; i++) {
                    (function(i) {
                        var tmpItem = getEl('upgradeItem' + i);
                        tmpItem.onclick = Utils.checkTrusted(function() {
                            io.send("upgrade", "H", i);
                        });
                        Utils.hookTouchEvents(tmpItem);
                    })(tmpList[i]);
                }
                if (tmpList.length) {
                    upgradeHolder.style.display = "block";
                    upgradeCounter.style.display = "block";
                    upgradeCounter.innerHTML = "SELECT ITEMS (" + points + ")";
                } else {
                    upgradeHolder.style.display = "none";
                    upgradeCounter.style.display = "none";
                }
            } else {
                upgradeHolder.style.display = "none";
                upgradeCounter.style.display = "none";
            }
        }

        function sendUpgrade(index) {
            io.send("upgrade", "H", index);
        }

        // UPDATE AGE:
        function updateAge(xp, mxp, age) {
            if (xp != undefined) {
                player.XP = xp;
            }
            if (mxp != undefined) {
                player.maxXP = mxp;
            }
            if (age != undefined) {
                player.age = age;
            }
            if (age == config.maxAge) {
                ageText.innerHTML = "MAX AGE";
                ageBarBody.style.width = "100%";
            } else {
                ageText.innerHTML = "AGE " + player.age;
                ageBarBody.style.width = ((player.XP / player.maxXP) * 100) + "%";
            }
        }

        // UPDATE LEADERBOARD:
        function updateLeaderboard(data) {
            Utils.removeAllChildren(leaderboardData);
            var tmpC = 1;
            for (let i = 0; i < data.length; i += 3) {
                (function(i) {
                    Utils.generateElement({
                        class: "leaderHolder",
                        parent: leaderboardData,
                        children: [
                            Utils.generateElement({
                                class: "leaderboardItem",
                                style: "color:" + ((data[i] == playerSID) ? "#fff" : "rgba(255,255,255,0.6)"),
                                text: tmpC + ". " + (data[i + 1] != "" ? data[i + 1] : "unknown")
                            }),
                            Utils.generateElement({
                                class: "leaderScore",
                                text: Utils.kFormat(data[i + 2]) || "0"
                            })
                        ]
                    });
                })(i);
                tmpC++;
            }
        }
        // Okk mod core here

        function selectWeapon(index, isPlace) {
            if (!isPlace) {
                player.holdWeapon = index;
            }
            io.send("select", "z", index, 1);
        }
        function sendAtck(id, angle) {
            io.send("attack", "F", id, angle, 1);
        }

        // Placing
        function place(id, rad) { // Place
            try {
                if (id == undefined) return;
                let item = items.list[player.items[id]];
                let tmpS = player.scale + item.scale + (item.placeOffset || 0);
                let tmpX = player.x2 + tmpS * cos(rad);
                let tmpY = player.y2 + tmpS * sin(rad);
                if (id === 0 || (player.alive && inGame && player.itemCounts[item.group.id] == undefined ? true : player.itemCounts[item.group.id] < (config.isSandbox ? id === 3 || id === 5 ? 299 : 99 : item.group.limit ? item.group.limit : 99))) {
                    selectToBuild(player.items[id]);
                    sendAtck(1, rad);
                    selectWeapon(player.holdWeapon, 1);
                }
            } catch (e) {}
        };
        function checkPlace(id, rad) {
            try {
                if (id == undefined) return;
                let item = items.list[player.items[id]];
                let tmpS = player.scale + item.scale + (item.placeOffset || 0);
                let tmpX = player.x2 + tmpS * cos(rad);
                let tmpY = player.y2 + tmpS * sin(rad);
                if (objectManager.checkItemLocation(tmpX, tmpY, item.scale, 0.6, item.id, false)) {
                    place(id, rad);
                }
            } catch (e) {};
        };
        function Cplace(id, first = -(pi_2), repeat = (pi_2), plus = (pi/18), radian) {
            let item = items.list[player.items[id]];
            let tmpS = player.scale + item.scale + (item.placeOffset || 0);
            let counts = {
                attempts: 0,
                placed: 0,
            };
            let tmpObjects = [];
            gameObjects.forEach((p) => {
                tmpObjects.push({x: p.x,y: p.y, active: p.active, blocker: p.blocker, scale: p.scale, isItem: p.isItem, type: p.type, colDiv: p.colDiv, getScale: function(sM, ig) {sM = sM||1; return this.scale * ((this.isItem||this.type==2||this.type==3||this.type==4) ?1:(0.6*sM)) * (ig?1:this.colDiv);},});
            });
            for (let i = first; i <= repeat; i += plus) {
                counts.attempts++;
                let relAim = radian + i;
                let tmpX = player.x2 + tmpS * cos(relAim);
                let tmpY = player.y2 + tmpS * sin(relAim);
                let cantPlace = tmpObjects.find((tmp) => tmp.active && Utils.getDistance(tmpX, tmpY, tmp.x, tmp.y) < item.scale + (tmp.blocker ? tmp.blocker : tmp.getScale(0.6, tmp.isItem)));
                if (cantPlace) continue;
                if (item.id != 18 && tmpY >= config.mapScale / 2 - config.riverWidth / 2 && tmpY <= config.mapScale / 2 + config.riverWidth / 2) continue;
                place(id, relAim);
            }
        };
        class Autobuy {
            constructor(items) {
                this.items = items;
            }
            buyNext() {
                for (const [id, type] of this.items) {
                    const find = type === 0 ? findID(hats, id) : findID(accessories, id);
                    const isOwned = type === 0 ? player.skins[id] : player.tails[id];
                    if (!find || isOwned) continue;
                    if (player.points >= find.price) {
                        io.send("hatAccs", "c", 1, id, type);
                        if (id == 7 && type == 0) my.reSync = true;
                        return;
                    }
                    return;
                }
            }
        }
        let autoBuy = new Autobuy([[11, 1], [40, 0], [6, 0], [7, 0], [31, 0], [15, 0], [19, 1], [22, 0], [53, 0], [12, 0], [20, 0], [10, 0], [56, 0], [21, 1], [11, 1], [26, 0], [18, 1], [13, 1]])
       class hataccss { // this shit not working :D
         constructor() {
         }
         storeEquip(id, index) {
           if (!inGame) return;
           if (index == 0) {
             if (id > 0 && !player.skins[id]) return;
                if (player.skinIndex != id) {
                  io.send("hatAccs", "13c", 0, id, 0);
             }
           } else {
             if (id > 0 && !player.tails[id]) return;
                if (player.tailIndex != id) {
               io.send("hatAccs", "13c", 0, id, 1);
             }
            }
         }
         biomeAuto() {
         }
         auto() {
           if (clicks.left || clicks.right) {
             if (clicks.left) {

              } else if (clicks.right) {

              }
           } else {
             this.storeEquip(11, 1);
           }

         }
      }
      let HatAcc = new hataccss();

        // Night Mode idk
        UI.addStyle('nightModeStyles', `
    #nightMode {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgb(0, 0, 100);
        opacity: 0;
        pointer-events: none;
        animation: night1 5s forwards;
    }

    @keyframes night1 {
        from { opacity: 0; }
        to { opacity: 0.35; }
    }
`);
        let nightMode = document.createElement("div");
        nightMode.id = "nightMode";
        document.body.appendChild(nightMode);
        nightMode.style.animationName = 'night1';

        // UPDATE GAME:
        function updateGame() {

            if (true) {

                // UPDATE DIRECTION:
                if (player) {
                    if (!lastSent || now - lastSent >= (1000 / config.clientSendRate)) {
                        lastSent = now;
                        io.send("dir", "D", getAttackDir());
                    }
                }

                // DEATH TEXT:
                if (deathTextScale < 120) {
                    deathTextScale += 0.1 * delta;
                    diedText.style.fontSize = min(round(deathTextScale), 120) + "px";
                }

                // MOVE CAMERA:
                if (player) {
                    let width, targetScreenHeight;
                    let smoothness = 0.1;
                    let pullFactor = 0;
                    let targetX = player.x;
                    let targetY = player.y;
                    width = config.maxScreenWidth;
                    targetScreenHeight = config.maxScreenHeight;
                    if (pullFactor === 0) {
                        width *= 1.2;
                        targetScreenHeight *= 1.4;
                    }
                    camX = (camX * 24 + targetX) / 25;
                    camY = (camY * 24 + targetY) / 25;
                    camX = max(540, min(13840, camX));
                    camY = max(200, min(14240, camY));
                    maxScreenWidth += (width - maxScreenWidth) * smoothness;
                    maxScreenHeight += (targetScreenHeight - maxScreenHeight) * smoothness;
                    resize();
                } else {
                    camX = max(540, min(13840, config.mapScale / 2));
                    camY = max(200, min(14240, config.mapScale / 2));
                    resize();
                }

                // INTERPOLATE PLAYERS AND AI:
                var lastTime = now - (1000 / config.serverUpdateRate);
                var tmpDiff;
                for (let i = 0; i < players.length + ais.length; ++i) {
                    tmpObj = players[i] || ais[i - players.length];
                    if (tmpObj && tmpObj.visible) {
                        if (tmpObj.forcePos) {
                            tmpObj.x = tmpObj.x2;
                            tmpObj.y = tmpObj.y2;
                            tmpObj.dir = tmpObj.d2;
                        } else {
                            var total = tmpObj.t2 - tmpObj.t1;
                            var fraction = lastTime - tmpObj.t1;
                            var ratio = (fraction / total);
                            var rate = 170;
                            tmpObj.dt += delta;
                            var tmpRate = min(1.7, tmpObj.dt / rate);
                            let tmpDiff = (tmpObj.x2 - tmpObj.x1);
                            tmpObj.x = tmpObj.x1 + (tmpDiff * tmpRate);
                            tmpDiff = (tmpObj.y2 - tmpObj.y1);
                            tmpObj.y = tmpObj.y1 + (tmpDiff * tmpRate);
                            tmpObj.dir = lerpAngle(tmpObj.d2, tmpObj.d1, min(1.2, ratio));
                        }
                    }
                }

                // RENDER CORDS:
                var xOffset = camX - (maxScreenWidth / 2);
                var yOffset = camY - (maxScreenHeight / 2);
                volcano.xof = xOffset;
                volcano.yof = yOffset;

                // RENDER BACKGROUND:
                if (config.snowBiomeTop - yOffset <= 0 && config.mapScale - config.snowBiomeTop - yOffset >= maxScreenHeight) {
                    ctx.fillStyle = "#b6db66";
                    ctx.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                } else if (config.mapScale - config.snowBiomeTop - yOffset <= 0) {
                    ctx.fillStyle = "#dbc666";
                    ctx.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                } else if (config.snowBiomeTop - yOffset >= maxScreenHeight) {
                    ctx.fillStyle = "#fff";
                    ctx.fillRect(0, 0, maxScreenWidth, maxScreenHeight);
                } else if (config.snowBiomeTop - yOffset >= 0) {
                    ctx.fillStyle = "#fff";
                    ctx.fillRect(0, 0, maxScreenWidth, config.snowBiomeTop - yOffset);
                    ctx.fillStyle = "#b6db66";
                    ctx.fillRect(0, config.snowBiomeTop - yOffset, maxScreenWidth,
                                 maxScreenHeight - (config.snowBiomeTop - yOffset));
                } else {
                    ctx.fillStyle = "#b6db66";
                    ctx.fillRect(0, 0, maxScreenWidth,
                                 (config.mapScale - config.snowBiomeTop - yOffset));
                    ctx.fillStyle = "#dbc666";
                    ctx.fillRect(0, (config.mapScale - config.snowBiomeTop - yOffset), maxScreenWidth,
                                 maxScreenHeight - (config.mapScale - config.snowBiomeTop - yOffset));
                }

                // RENDER WATER AREAS:
                if (!firstSetup) {
                    waterMult += waterPlus * config.waveSpeed * delta;
                    if (waterMult >= config.waveMax) {
                        waterMult = config.waveMax;
                        waterPlus = -1;
                    } else if (waterMult <= 1) {
                        waterMult = waterPlus = 1;
                    }
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = "#dbc666";
                    renderWaterBodies(xOffset, yOffset, ctx, config.riverPadding);
                    ctx.fillStyle = "#91b2db";
                    renderWaterBodies(xOffset, yOffset, ctx, (waterMult - 1) * 250);
                }

                // RENDER BOTTOM LAYER:
                ctx.globalAlpha = 1;
                ctx.strokeStyle = outlineColor;
                renderGameObjects(-1, xOffset, yOffset);

                // RENDER PROJECTILES:
                ctx.globalAlpha = 1;
                ctx.lineWidth = outlineWidth;
                renderProjectiles(0, xOffset, yOffset);

                // RENDER PLAYERS:
                renderPlayers(xOffset, yOffset, 0);

                // RENDER AI:
                ctx.globalAlpha = 1;
                for (let i = 0; i < ais.length; ++i) {
                    tmpObj = ais[i];
                    if (tmpObj.active && tmpObj.visible) {
                        tmpObj.animate(delta);
                        ctx.save();
                        ctx.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);
                        ctx.rotate(tmpObj.dir + tmpObj.dirPlus - pi_2);
                        renderAI(tmpObj, ctx);
                        ctx.restore();
                    }
                }

                // RENDER GAME OBJECTS (LAYERED):
                renderGameObjects(0, xOffset, yOffset);
                renderProjectiles(1, xOffset, yOffset);
                renderGameObjects(1, xOffset, yOffset);
                renderPlayers(xOffset, yOffset, 1);
                renderGameObjects(2, xOffset, yOffset);
                renderGameObjects(3, xOffset, yOffset);

                // MAP BOUNDARIES:
                ctx.fillStyle = "#000";
                ctx.globalAlpha = 0.09;
                if (xOffset <= 0) {
                    ctx.fillRect(0, 0, -xOffset, maxScreenHeight);
                }
                if (config.mapScale - xOffset <= maxScreenWidth) {
                    var tmpY = max(0, -yOffset);
                    ctx.fillRect(config.mapScale - xOffset, tmpY, maxScreenWidth - (config.mapScale - xOffset), maxScreenHeight - tmpY);
                }
                if (yOffset <= 0) {
                    ctx.fillRect(-xOffset, 0, maxScreenWidth + xOffset, -yOffset);
                }
                if (config.mapScale - yOffset <= maxScreenHeight) {
                    var tmpX = max(0, -xOffset);
                    var tmpMin = 0;
                    if (config.mapScale - xOffset <= maxScreenWidth) {
                        tmpMin = maxScreenWidth - (config.mapScale - xOffset);
                    }
                    ctx.fillRect(tmpX, config.mapScale - yOffset,
                                 (maxScreenWidth - tmpX) - tmpMin, maxScreenHeight - (config.mapScale - yOffset));
                }

                // RENDER DAY/NIGHT TIME:
                ctx.globalAlpha = 1;
                ctx.fillStyle = "rgba(0, 0, 70, 0.35)";
                ctx.fillRect(0, 0, maxScreenWidth, maxScreenHeight);

                // RENDER PLAYER AND AI UI:
                ctx.strokeStyle = darkOutlineColor;
                for (let i = 0; i < players.length + ais.length; ++i) {
                    tmpObj = players[i] || ais[i - players.length];
                    if (tmpObj.visible) {

                        // NAME AND HEALTH:
                        if (tmpObj.skinIndex != 10 || (tmpObj == player) || (tmpObj.team && tmpObj.team == player.team)) {
                            var tmpText = (tmpObj.team ? "[" + tmpObj.team + "] " : "") + (tmpObj.name || "") + (tmpObj.isPlayer ? " {" + tmpObj.sid + "} " : "");
                            if (tmpText != "") {
                                ctx.globalAlpha = 1;
                                ctx.font = (tmpObj.nameScale || 18) + "px Hammersmith One";
                                ctx.fillStyle = "#fff";
                                ctx.textBaseline = "middle";
                                ctx.textAlign = "center";
                                ctx.lineWidth = (tmpObj.nameScale ? 11 : 8);
                                ctx.lineJoin = "round";
                                ctx.strokeText(tmpText, tmpObj.x - xOffset, (tmpObj.y - yOffset - tmpObj.scale) - config.nameY + 125);
                                ctx.fillText(tmpText, tmpObj.x - xOffset, (tmpObj.y - yOffset - tmpObj.scale) - config.nameY + 125);
                                if (tmpObj.isLeader && iconSprites.crown.isLoaded) {
                                    let tmpS = config.crownIconScale;
                                    let tmpX = tmpObj.iconIndex === 1 ? (tmpObj.x - xOffset - (tmpS/2) - (iconSprites.crown.width / 2) + 145) : (tmpObj.x - xOffset - (tmpS/2) - (iconSprites.crown.width / 2) + 129);
                                    let tmpY = tmpObj.y - yOffset - tmpObj.scale - config.nameY - (tmpS/2) - 5;
                                    ctx.drawImage(iconSprites.crown, tmpX, tmpY, tmpS, tmpS);
                                }
                                if (tmpObj.iconIndex === 1 && iconSprites.skull.isLoaded) {
                                    let tmpS = config.crownIconScale;
                                    let tmpX = tmpObj.isLeader ? (tmpObj.x - xOffset - (tmpS/2) - iconSprites.skull.width / 2 + 100) : (tmpObj.x - xOffset - (tmpS/2) - iconSprites.skull.width / 2 + 129);
                                    let tmpY = tmpObj.y - yOffset - tmpObj.scale - config.nameY - (tmpS/2) - 5;
                                    ctx.drawImage(iconSprites.skull, tmpX, tmpY, tmpS, tmpS);
                                }
                            }
                            if (tmpObj.health > 0) {

                                // HEALTH HOLDER:
                                var tmpWidth = config.healthBarWidth;
                                ctx.fillStyle = darkOutlineColor;
                                ctx.roundRect(tmpObj.x - xOffset - config.healthBarWidth - config.healthBarPad,
                                              (tmpObj.y - yOffset + tmpObj.scale) + config.nameY, (config.healthBarWidth * 2) +
                                              (config.healthBarPad * 2), 17, 8);
                                ctx.fill();

                                // HEALTH BAR:
                                ctx.fillStyle = (tmpObj == player || (tmpObj.team && tmpObj.team == player.team)) ? "#8ecc51" : "#cc5151";
                                ctx.roundRect(tmpObj.x - xOffset - config.healthBarWidth,
                                              (tmpObj.y - yOffset + tmpObj.scale) + config.nameY + config.healthBarPad,
                                              ((config.healthBarWidth * 2) * (tmpObj.health / tmpObj.maxHealth)), 17 - config.healthBarPad * 2, 7);
                                ctx.fill();
                            }
                        }
                    }
                }

                // RENDER ANIM TEXTS:
                textManager.update(delta);
                textManager.render(ctx, xOffset, yOffset);

                // RENDER CHAT MESSAGES:
                for (let i = 0; i < players.length; ++i) {
                    tmpObj = players[i];
                    if (tmpObj.visible && tmpObj.chatCountdown > 0) {
                        tmpObj.chatCountdown -= delta;
                        if (tmpObj.chatCountdown <= 0) {
                            tmpObj.chatCountdown = 0;
                        }
                        ctx.font = "32px Hammersmith One";
                        var tmpSize = ctx.measureText(tmpObj.chatMessage);
                        ctx.textBaseline = "middle";
                        ctx.textAlign = "center";
                        let tmpX = tmpObj.x - xOffset;
                        let tmpY = tmpObj.y - tmpObj.scale - yOffset - 90;
                        var tmpH = 47;
                        var tmpW = tmpSize.width + 17;
                        ctx.fillStyle = "rgba(0,0,0,0.2)";
                        ctx.roundRect(tmpX - tmpW / 2, tmpY - tmpH / 2, tmpW, tmpH, 6);
                        ctx.fill();
                        ctx.fillStyle = "#fff";
                        ctx.fillText(tmpObj.chatMessage, tmpX, tmpY);
                    }
                }
            }

            // RENDER MINIMAP:
            renderMinimap(delta);

        }

        // RENDER PROJECTILES:
        function renderProjectiles(layer, xOffset, yOffset) {
            for (let i = 0; i < projectiles.length; ++i) {
                tmpObj = projectiles[i];
                if (tmpObj.active && tmpObj.layer == layer) {
                    tmpObj.update(delta);
                    if (tmpObj.active && isOnScreen(tmpObj.x - xOffset, tmpObj.y - yOffset, tmpObj.scale)) {
                        ctx.save();
                        ctx.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);
                        ctx.rotate(tmpObj.dir);
                        renderProjectile(0, 0, tmpObj, ctx, 1);
                        ctx.restore();
                    }
                }
            }
        }

        // RENDER PROJECTILE:
        var projectileSprites = {};

        function renderProjectile(x, y, obj, ctxt, debug) {
            if (obj.src) {
                var tmpSrc = items.projectiles[obj.indx].src;
                var tmpSprite = projectileSprites[tmpSrc];
                if (!tmpSprite) {
                    tmpSprite = new Image();
                    tmpSprite.onload = function() {
                        this.isLoaded = true;
                    }
                    tmpSprite.src = ".././img/weapons/" + tmpSrc + ".png";
                    projectileSprites[tmpSrc] = tmpSprite;
                }
                if (tmpSprite.isLoaded) {
                    ctxt.drawImage(tmpSprite, x - (obj.scale / 2), y - (obj.scale / 2), obj.scale, obj.scale);
                }
            } else if (obj.indx == 1) {
                ctxt.fillStyle = "#939393";
                renderCircle(x, y, obj.scale, ctxt);
            }
        }

        // RENDER WATER BODIES:
        function renderWaterBodies(xOffset, yOffset, ctxt, padding) {

            // MIDDLE RIVER:
            var tmpW = config.riverWidth + padding;
            var tmpY = (config.mapScale / 2) - yOffset - (tmpW / 2);
            if (tmpY < maxScreenHeight && tmpY + tmpW > 0) {
                ctxt.fillRect(0, tmpY, maxScreenWidth, tmpW);
            }
        }
        function createVolcano() {
            let volcanoDimension = config.volcanoScale * 2;
            let landCanvas = document.createElement("canvas");
            landCanvas.width = volcanoDimension;
            landCanvas.height = volcanoDimension;
            let landContext = landCanvas.getContext("2d");
            landContext.strokeStyle = "#3e3e3e";
            landContext.lineWidth = 5.5 * 2;
            landContext.fillStyle = "#7f7f7f";
            renderPolygon(landContext, 10, volcanoDimension);
            landContext.fill();
            landContext.stroke();
            volcano.land = landCanvas;

            let lavaCanvas = document.createElement("canvas");
            let lavaDimension = config.innerVolcanoScale * 2;
            lavaCanvas.width = lavaDimension;
            lavaCanvas.height = lavaDimension;

            let lavaContext = lavaCanvas.getContext("2d");
            lavaContext.strokeStyle = "#525252";
            lavaContext.lineWidth = 5.5 * 1.6;
            lavaContext.fillStyle = "#f54e16";
            lavaContext.strokeStyle = "#f56f16";

            renderPolygon(lavaContext, 10, lavaDimension);
            lavaContext.fill();
            lavaContext.stroke();
            volcano.lava = lavaCanvas;
        }
        createVolcano();

        // RENDER GAME OBJECTS:
        function renderGameObjects(layer, xOffset, yOffset) {
            var tmpSprite, tmpX, tmpY;
            for (let i = 0; i < gameObjects.length; ++i) {
                tmpObj = gameObjects[i];
                if (tmpObj.active) {
                    tmpX = tmpObj.x + tmpObj.xWiggle - xOffset;
                    tmpY = tmpObj.y + tmpObj.yWiggle - yOffset;
                    if (layer == 0) {
                        tmpObj.update(delta);
                    }
                    if (tmpObj.layer == layer && isOnScreen(tmpX, tmpY, tmpObj.scale + (tmpObj.blocker || 0))) {
                        ctx.globalAlpha = tmpObj.hideFromEnemy ? 0.6 : 1;
                        if (tmpObj.isItem) {
                            tmpSprite = getItemSprite(tmpObj);
                            ctx.save();
                            ctx.translate(tmpX, tmpY);
                            ctx.rotate(tmpObj.dir);
                            ctx.drawImage(tmpSprite, -(tmpSprite.width / 2), -(tmpSprite.height / 2));
                            if (tmpObj.blocker) {
                                ctx.strokeStyle = "#db6e6e";
                                ctx.globalAlpha = 0.3;
                                ctx.lineWidth = 6;
                                renderCircle(0, 0, tmpObj.blocker, ctx, false, true);
                            }
                            ctx.restore();
                        } else {
                            if (tmpObj.type == 4) {
                                let XOffset = volcano.xof
                                let YOffset = volcano.yof
                                volcano.animationTime += delta;
                                volcano.animationTime %= config.volcanoAnimationDuration;
                                let halfAnimationDuration = config.volcanoAnimationDuration / 2;
                                let lavaScaleFactor = 1.7 + .3 * (abs(halfAnimationDuration - volcano.animationTime) / halfAnimationDuration);
                                let finalLavaScale = config.innerVolcanoScale * lavaScaleFactor;
                                ctx.drawImage(volcano.land, volcano.x - config.volcanoScale - XOffset, volcano.y - config.volcanoScale - YOffset, config.volcanoScale * 2, config.volcanoScale * 2);
                                ctx.drawImage(volcano.lava, volcano.x - finalLavaScale - XOffset, volcano.y - finalLavaScale - YOffset, finalLavaScale * 2, finalLavaScale * 2);
                            } else {
                                tmpSprite = getResSprite(tmpObj);
                                ctx.drawImage(tmpSprite, tmpX - tmpSprite.width / 2, tmpY - tmpSprite.height / 2);
                            }
                        }
                    }
                }
            }
        }
        // GATHER ANIMATION:
        function gatherAnimation(sid, didHit, index) {
            tmpObj = findPlayerBySID(sid);
            if (tmpObj) tmpObj.startAnim(didHit, index);
        }

        // RENDER PLAYERS:
        function renderPlayers(xOffset, yOffset, zIndex) {
            ctx.globalAlpha = 1;
            for (let i = 0; i < players.length; ++i) {
                tmpObj = players[i];
                if (tmpObj.zIndex == zIndex) {
                    tmpObj.animate(delta);
                    if (tmpObj.visible) {
                        tmpObj.skinRot += (0.002 * delta);
                        tmpDir = ((tmpObj == player) ? getAttackDir() : tmpObj.dir) + tmpObj.dirPlus;
                        ctx.save();
                        ctx.translate(tmpObj.x - xOffset, tmpObj.y - yOffset);

                        // RENDER PLAYER:
                        ctx.rotate(tmpDir);
                        renderPlayer(tmpObj, ctx);
                        ctx.restore();
                    }
                }
            }
        }

        // RENDER PLAYER:
        function renderPlayer(obj, ctxt) {
            ctxt = ctxt || ctx;
            ctxt.lineWidth = outlineWidth;
            ctxt.lineJoin = "miter";
            var handAngle = (pi_4) * (items.weapons[obj.weaponIndex].armS || 1);
            var oHandAngle = (obj.buildIndex < 0) ? (items.weapons[obj.weaponIndex].hndS || 1) : 1;
            var oHandDist = (obj.buildIndex < 0) ? (items.weapons[obj.weaponIndex].hndD || 1) : 1;

            // TAIL/CAPE:
            if (obj.tailIndex > 0) {
                renderTail(obj.tailIndex, ctxt, obj);
            }

            // WEAPON BELLOW HANDS:
            if (obj.buildIndex < 0 && !items.weapons[obj.weaponIndex].aboveHand) {
                renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
                if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                    renderProjectile(obj.scale, 0,
                                     items.projectiles[items.weapons[obj.weaponIndex].projectile], ctx);
                }
            }

            // HANDS:
            ctxt.fillStyle = config.skinColors[obj.skinColor];
            renderCircle(obj.scale * cos(handAngle), (obj.scale * sin(handAngle)), 14);
            renderCircle((obj.scale * oHandDist) * cos(-handAngle * oHandAngle),
                         (obj.scale * oHandDist) * sin(-handAngle * oHandAngle), 14);

            // WEAPON ABOVE HANDS:
            if (obj.buildIndex < 0 && items.weapons[obj.weaponIndex].aboveHand) {
                renderTool(items.weapons[obj.weaponIndex], config.weaponVariants[obj.weaponVariant].src, obj.scale, 0, ctxt);
                if (items.weapons[obj.weaponIndex].projectile != undefined && !items.weapons[obj.weaponIndex].hideProjectile) {
                    renderProjectile(obj.scale, 0,
                                     items.projectiles[items.weapons[obj.weaponIndex].projectile], ctx);
                }
            }

            // BUILD ITEM:
            if (obj.buildIndex >= 0) {
                var tmpSprite = getItemSprite(items.list[obj.buildIndex]);
                ctxt.drawImage(tmpSprite, obj.scale - items.list[obj.buildIndex].holdOffset, -tmpSprite.width / 2);
            }

            // BODY:
            renderCircle(0, 0, obj.scale, ctxt);

            // SKIN:
            if (obj.skinIndex > 0) {
                ctxt.rotate(pi_2);
                renderSkin(obj.skinIndex, ctxt, null, obj);
            }
        }

        // RENDER SKINS:
        var skinSprites = {};
        var skinPointers = {};
        var tmpSkin;

        function renderSkin(index, ctxt, parentSkin, owner) {
            tmpSkin = skinSprites[index];
            if (!tmpSkin) {
                var tmpImage = new Image();
                tmpImage.onload = function() {
                    this.isLoaded = true;
                    this.onload = null;
                };
                tmpImage.src = ".././img/hats/hat_" + index + ".png";
                skinSprites[index] = tmpImage;
                tmpSkin = tmpImage;
            }
            var tmpObj = parentSkin || skinPointers[index];
            if (!tmpObj) {
                for (let i = 0; i < hats.length; ++i) {
                    if (hats[i].id == index) {
                        tmpObj = hats[i];
                        break;
                    }
                }
                skinPointers[index] = tmpObj;
            }
            if (tmpSkin.isLoaded) {
                ctxt.drawImage(tmpSkin, -tmpObj.scale / 2, -tmpObj.scale / 2, tmpObj.scale, tmpObj.scale);
            }
            if (!parentSkin && tmpObj.topSprite) {
                ctxt.save();
                ctxt.rotate(owner.skinRot);
                renderSkin(index + "_top", ctxt, tmpObj, owner);
                ctxt.restore();
            }
        }

        // RENDER TAIL:
        var accessSprites = {};
        var accessPointers = {};

        function renderTail(index, ctxt, owner) {
            tmpSkin = accessSprites[index];
            if (!tmpSkin) {
                var tmpImage = new Image();
                tmpImage.onload = function() {
                    this.isLoaded = true;
                    this.onload = null;
                };
                tmpImage.src = ".././img/accessories/access_" + index + ".png";
                accessSprites[index] = tmpImage;
                tmpSkin = tmpImage;
            }
            var tmpObj = accessPointers[index];
            if (!tmpObj) {
                for (let i = 0; i < accessories.length; ++i) {
                    if (accessories[i].id == index) {
                        tmpObj = accessories[i];
                        break;
                    }
                }
                accessPointers[index] = tmpObj;
            }
            if (tmpSkin.isLoaded) {
                ctxt.save();
                ctxt.translate(-20 - (tmpObj.xOff || 0), 0);
                if (tmpObj.spin) {
                    ctxt.rotate(owner.skinRot);
                }
                ctxt.drawImage(tmpSkin, -(tmpObj.scale / 2), -(tmpObj.scale / 2), tmpObj.scale, tmpObj.scale);
                ctxt.restore();
            }
        }

        // RENDER TOOL:
        var toolSprites = {};

        function renderTool(obj, variant, x, y, ctxt) {
            var tmpSrc = obj.src + (variant || "");
            var tmpSprite = toolSprites[tmpSrc];
            if (!tmpSprite) {
                tmpSprite = new Image();
                tmpSprite.onload = function() {
                    this.isLoaded = true;
                }
                tmpSprite.src = ".././img/weapons/" + tmpSrc + ".png";
                toolSprites[tmpSrc] = tmpSprite;
            }
            if (tmpSprite.isLoaded) {
                ctxt.drawImage(tmpSprite, x + obj.xOff - (obj.length / 2), y + obj.yOff - (obj.width / 2), obj.length, obj.width);
            }
        }

        // RENDER GAME OBJECTS:
        var gameObjectSprites = {};

        function getResSprite(obj) {
            var biomeID = (obj.y >= config.mapScale - config.snowBiomeTop) ? 2 : ((obj.y <= config.snowBiomeTop) ? 1 : 0);
            var tmpIndex = (obj.type + "_" + obj.scale + "_" + biomeID);
            var tmpSprite = gameObjectSprites[tmpIndex];
            if (!tmpSprite) {
                var tmpCanvas = document.createElement('canvas');
                tmpCanvas.width = tmpCanvas.height = (obj.scale * 2.1) + outlineWidth;
                var tmpContext = tmpCanvas.getContext('2d');
                tmpContext.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
                tmpContext.rotate(Utils.randFloat(0, pi));
                tmpContext.strokeStyle = outlineColor;
                tmpContext.lineWidth = outlineWidth;
                tmpContext.shadowBlur = 15;
                tmpContext.shadowColor = `rgba(0, 0, 0, 5)`;
                if (obj.type == 0) {
                    let tmpScale;
                    let tmpCount = Utils.randInt(5, 7);
                    tmpContext.globalAlpha = 0.8;
                    for (let i = 0; i < 2; ++i) {
                        tmpScale = tmpObj.scale * (!i?1:0.5);
                        renderStar(tmpContext, tmpCount, tmpScale, tmpScale * 0.7);
                        tmpContext.fillStyle = !biomeID?(!i?"#9ebf57":"#b4db62"):(!i?"#e3f1f4":"#fff");
                        tmpContext.fill();
                        if (!i) {
                            tmpContext.stroke();
                            tmpContext.shadowBlur = null;
                            tmpContext.shadowColor = null;
                            tmpContext.globalAlpha = 1;
                        }
                    }
                } else if (obj.type == 1) {
                    if (biomeID == 2) {
                        tmpContext.fillStyle = "#606060";
                        renderStar(tmpContext, 6, obj.scale * 0.3, obj.scale * 0.71);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = "#89a54c";
                        renderCircle(0, 0, obj.scale * 0.55, tmpContext);
                        tmpContext.fillStyle = "#a5c65b";
                        renderCircle(0, 0, obj.scale * 0.3, tmpContext, true);
                    } else {
                        renderBlob(tmpContext, 6, tmpObj.scale, tmpObj.scale * 0.7);
                        tmpContext.fillStyle = biomeID ? "#e3f1f4" : "#89a54c";
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpContext.fillStyle = biomeID ? "#6a64af" : "#c15555";
                        var tmpRange;
                        var berries = 4;
                        var rotVal = pi2 / berries;
                        for (let i = 0; i < berries; ++i) {
                            tmpRange = Utils.randInt(tmpObj.scale / 3.5, tmpObj.scale / 2.3);
                            renderCircle(tmpRange * cos(rotVal * i), tmpRange * sin(rotVal * i),
                                         Utils.randInt(10, 12), tmpContext);
                        }
                    }
                } else if (obj.type == 2 || obj.type == 3) {
                    tmpContext.fillStyle = (obj.type == 2) ? (biomeID == 2 ? "#938d77" : "#939393") : "#e0c655";
                    renderStar(tmpContext, 3, obj.scale, obj.scale);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = (obj.type == 2) ? (biomeID == 2 ? "#b2ab90" : "#bcbcbc") : "#ebdca3";
                    renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
                    tmpContext.fill();
                }
                tmpSprite = tmpCanvas;
                gameObjectSprites[tmpIndex] = tmpSprite;
            }
            return tmpSprite;
        }

        // GET ITEM SPRITE:
        var itemSprites = [];

        function getItemSprite(obj, asIcon) {
            var tmpSprite = itemSprites[obj.id];
            if (!tmpSprite || asIcon) {
                var tmpCanvas = document.createElement('canvas');
                tmpCanvas.width = tmpCanvas.height = (obj.scale * 2.5) + outlineWidth +
                    (items.list[obj.id].spritePadding || 0);
                var tmpContext = tmpCanvas.getContext('2d');
                tmpContext.translate((tmpCanvas.width / 2), (tmpCanvas.height / 2));
                tmpContext.rotate(asIcon ? 0 : pi_2);
                tmpContext.strokeStyle = outlineColor;
                tmpContext.lineWidth = outlineWidth * (asIcon ? (tmpCanvas.width / 81) : 1);
                if (!asIcon) {
                    tmpContext.shadowBlur = 10;
                    tmpContext.shadowColor = `rgba(0, 0, 0, 0.5)`;
                }
                if (obj.name == "apple") {
                    tmpContext.fillStyle = "#c15555";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fillStyle = "#89a54c";
                    var leafDir = -pi_2;
                    renderLeaf(obj.scale * cos(leafDir), obj.scale * sin(leafDir),
                               25, leafDir + pi_2, tmpContext);
                } else if (obj.name == "cookie") {
                    tmpContext.fillStyle = "#cca861";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fillStyle = "#937c4b";
                    var chips = 4;
                    var rotVal = pi2 / chips;
                    var tmpRange;
                    for (let i = 0; i < chips; ++i) {
                        tmpRange = Utils.randInt(obj.scale / 2.5, obj.scale / 1.7);
                        renderCircle(tmpRange * cos(rotVal * i), tmpRange * sin(rotVal * i),
                                     Utils.randInt(4, 5), tmpContext, true);
                    }
                } else if (obj.name == "cheese") {
                    tmpContext.fillStyle = "#f4f3ac";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fillStyle = "#c3c28b";
                    let chips = 4;
                    let rotVal = pi2 / chips;
                    let tmpRange;
                    for (let i = 0; i < chips; ++i) {
                        tmpRange = Utils.randInt(obj.scale / 2.5, obj.scale / 1.7);
                        renderCircle(tmpRange * cos(rotVal * i), tmpRange * sin(rotVal * i),
                                     Utils.randInt(4, 5), tmpContext, true);
                    }
                } else if (obj.name == "wood wall" || obj.name == "stone wall" || obj.name == "castle wall") {
                    tmpContext.fillStyle = (obj.name == "castle wall") ? "#83898e" : (obj.name == "wood wall") ?
                        "#a5974c" : "#939393";
                    var sides = (obj.name == "castle wall") ? 4 : 3;
                    renderStar(tmpContext, sides, obj.scale * 1.1, obj.scale * 1.1);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = (obj.name == "castle wall") ? "#9da4aa" : (obj.name == "wood wall") ?
                        "#c9b758" : "#bcbcbc";
                    renderStar(tmpContext, sides, obj.scale * 0.65, obj.scale * 0.65);
                    tmpContext.fill();
                } else if (obj.name == "spikes" || obj.name == "greater spikes" || obj.name == "poison spikes" ||
                           obj.name == "spinning spikes") {
                    tmpContext.fillStyle = (obj.name == "poison spikes") ? "#7b935d" : "#939393";
                    var tmpScale = (obj.scale * 0.6);
                    renderStar(tmpContext, (obj.name == "spikes") ? 5 : 6, obj.scale, tmpScale);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#a5974c";
                    renderCircle(0, 0, tmpScale, tmpContext);
                    tmpContext.fillStyle = "#c9b758";
                    renderCircle(0, 0, tmpScale / 2, tmpContext, true);
                } else if (obj.name == "windmill" || obj.name == "faster windmill" || obj.name == "power mill") {
                    tmpContext.fillStyle = "#a5974c";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fillStyle = "#c9b758";
                    renderRectCircle(0, 0, obj.scale * 1.5, 29, 4, tmpContext);
                    tmpContext.fillStyle = "#a5974c";
                    renderCircle(0, 0, obj.scale * 0.5, tmpContext);
                } else if (obj.name == "mine") {
                    tmpContext.fillStyle = "#939393";
                    renderStar(tmpContext, 3, obj.scale, obj.scale);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#bcbcbc";
                    renderStar(tmpContext, 3, obj.scale * 0.55, obj.scale * 0.65);
                    tmpContext.fill();
                } else if (obj.name == "sapling") {
                    for (let i = 0; i < 2; ++i) {
                        let tmpScale = obj.scale * (!i ? 1 : 0.5);
                        renderStar(tmpContext, 7, tmpScale, tmpScale * 0.7);
                        tmpContext.fillStyle = (!i ? "#9ebf57" : "#b4db62");
                        tmpContext.fill();
                        if (!i) tmpContext.stroke();
                    }
                } else if (obj.name == "pit trap") {
                    tmpContext.fillStyle = "#a5974c";
                    renderStar(tmpContext, 3, obj.scale * 1.1, obj.scale * 1.1);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = outlineColor;
                    renderStar(tmpContext, 3, obj.scale * 0.65, obj.scale * 0.65);
                    tmpContext.fill();
                } else if (obj.name == "boost pad") {
                    tmpContext.fillStyle = "#7e7f82";
                    renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#dbd97d";
                    renderTriangle(obj.scale * 1, tmpContext);
                } else if (obj.name == "turret") {
                    tmpContext.fillStyle = "#a5974c";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#939393";
                    var tmpLen = 50;
                    renderRect(0, -tmpLen / 2, obj.scale * 0.9, tmpLen, tmpContext);
                    renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                } else if (obj.name == "platform") {
                    tmpContext.fillStyle = "#cebd5f";
                    var tmpCount = 4;
                    var tmpS = obj.scale * 2;
                    var tmpW = tmpS / tmpCount;
                    var tmpX = -(obj.scale / 2);
                    for (let i = 0; i < tmpCount; ++i) {
                        renderRect(tmpX - (tmpW / 2), 0, tmpW, obj.scale * 2, tmpContext);
                        tmpContext.fill();
                        tmpContext.stroke();
                        tmpX += tmpS / tmpCount;
                    }
                } else if (obj.name == "healing pad") {
                    tmpContext.fillStyle = "#7e7f82";
                    renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#db6e6e";
                    renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                } else if (obj.name == "spawn pad") {
                    tmpContext.fillStyle = "#7e7f82";
                    renderRect(0, 0, obj.scale * 2, obj.scale * 2, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.fillStyle = "#71aad6";
                    renderCircle(0, 0, obj.scale * 0.6, tmpContext);
                } else if (obj.name == "blocker") {
                    tmpContext.fillStyle = "#7e7f82";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.rotate(pi_4);
                    tmpContext.fillStyle = "#db6e6e";
                    renderRectCircle(0, 0, obj.scale * 0.65, 20, 4, tmpContext, true);
                } else if (obj.name == "teleporter") {
                    tmpContext.fillStyle = "#7e7f82";
                    renderCircle(0, 0, obj.scale, tmpContext);
                    tmpContext.fill();
                    tmpContext.stroke();
                    tmpContext.rotate(pi_4);
                    tmpContext.fillStyle = "#d76edb";
                    renderCircle(0, 0, obj.scale * 0.5, tmpContext, true);
                }
                tmpSprite = tmpCanvas;
                if (!asIcon) {
                    itemSprites[obj.id] = tmpSprite;
                }
            }
            return tmpSprite;
        }

        // RENDER LEAF:
        function renderLeaf(x, y, l, r, ctxt) {
            var endX = x + (l * cos(r));
            var endY = y + (l * sin(r));
            var width = l * 0.4;
            ctxt.moveTo(x, y);
            ctxt.beginPath();
            ctxt.quadraticCurveTo(((x + endX) / 2) + (width * cos(r + pi_2)),
                                  ((y + endY) / 2) + (width * sin(r + pi_2)), endX, endY);
            ctxt.quadraticCurveTo(((x + endX) / 2) - (width * cos(r + pi_2)),
                                  ((y + endY) / 2) - (width * sin(r + pi_2)), x, y);
            ctxt.closePath();
            ctxt.fill();
            ctxt.stroke();
        }

        // RENDER CIRCLE:
        function renderCircle(x, y, scale, tmpContext, dontStroke, dontFill) {
            tmpContext = tmpContext || ctx;
            tmpContext.beginPath();
            tmpContext.arc(x, y, scale, 0, pi2);
            if (!dontFill) tmpContext.fill();
            if (!dontStroke) tmpContext.stroke();
        }

        // RENDER STAR SHAPE:
        function renderStar(ctxt, spikes, outer, inner) {
            var rot = pi_2 * 3;
            var x, y;
            var step = pi / spikes;
            ctxt.beginPath();
            ctxt.moveTo(0, -outer);
            for (let i = 0; i < spikes; i++) {
                x = cos(rot) * outer;
                y = sin(rot) * outer;
                ctxt.lineTo(x, y);
                rot += step;
                x = cos(rot) * inner;
                y = sin(rot) * inner;
                ctxt.lineTo(x, y);
                rot += step;
            }
            ctxt.lineTo(0, -outer);
            ctxt.closePath();
        }

        // RENDER RECTANGLE:
        function renderRect(x, y, w, h, ctxt, stroke) {
            ctxt.fillRect(x - (w / 2), y - (h / 2), w, h);
            if (!stroke) {
                ctxt.strokeRect(x - (w / 2), y - (h / 2), w, h);
            }
        }

        // RENDER RECTCIRCLE:
        function renderRectCircle(x, y, s, sw, seg, ctxt, stroke) {
            ctxt.save();
            ctxt.translate(x, y);
            seg = ceil(seg / 2);
            for (let i = 0; i < seg; i++) {
                renderRect(0, 0, s * 2, sw, ctxt, stroke);
                ctxt.rotate(pi / seg);
            }
            ctxt.restore();
        }

        // RENDER BLOB:
        function renderBlob(ctxt, spikes, outer, inner) {
            var rot = pi_2 * 3;
            var x, y;
            var step = pi / spikes;
            var tmpOuter;
            ctxt.beginPath();
            ctxt.moveTo(0, -inner);
            for (let i = 0; i < spikes; i++) {
                tmpOuter = Utils.randInt(outer + 0.9, outer * 1.2);
                ctxt.quadraticCurveTo(cos(rot + step) * tmpOuter, sin(rot + step) * tmpOuter,
                                      cos(rot + (step * 2)) * inner, sin(rot + (step * 2)) * inner);
                rot += step * 2;
            }
            ctxt.lineTo(0, -inner);
            ctxt.closePath();
        }

        // RENDER TRIANGLE:
        function renderTriangle(s, ctx) {
            ctx = ctx || ctx;
            var h = s * (sqrt(3) / 2);
            ctx.beginPath();
            ctx.moveTo(0, -h / 2);
            ctx.lineTo(-s / 2, h / 2);
            ctx.lineTo(s / 2, h / 2);
            ctx.lineTo(0, -h / 2);
            ctx.fill();
            ctx.closePath();
        }

        // RENDER POLYGON:
        function renderPolygon(ctx, sides, diameter) {
            let lineWidth = ctx.lineWidth || 0;
            let radius = diameter / 2;
            ctx.beginPath();
            let angles = pi2 / sides;

            for (let index = 0; index < sides; index++) {
                let x = radius + (radius - lineWidth / 2) * cos(angles * index);
                let y = radius + (radius - lineWidth / 2) * sin(angles * index);
                ctx.lineTo(x, y);
            }

            ctx.closePath();
        }


        // PREPARE MENU BACKGROUND:
        function prepareMenuBackground() {
            var tmpMid = config.mapScale / 2;
            objectManager.add(0, tmpMid, tmpMid + 200, 0, config.treeScales[3], 0);
            objectManager.add(1, tmpMid, tmpMid - 480, 0, config.treeScales[3], 0);
            objectManager.add(2, tmpMid + 300, tmpMid + 450, 0, config.treeScales[3], 0);
            objectManager.add(3, tmpMid - 950, tmpMid - 130, 0, config.treeScales[2], 0);
            objectManager.add(4, tmpMid - 750, tmpMid - 400, 0, config.treeScales[3], 0);
            objectManager.add(5, tmpMid - 700, tmpMid + 400, 0, config.treeScales[2], 0);
            objectManager.add(6, tmpMid + 800, tmpMid - 200, 0, config.treeScales[3], 0);
            objectManager.add(7, tmpMid - 260, tmpMid + 340, 0, config.bushScales[3], 1);
            objectManager.add(8, tmpMid + 760, tmpMid + 310, 0, config.bushScales[3], 1);
            objectManager.add(9, tmpMid - 800, tmpMid + 100, 0, config.bushScales[3], 1);
            objectManager.add(12, tmpMid - 400, tmpMid - 450, 0, config.rockScales[2], 2);
        }

        // LOAD GAME OBJECT:
        function loadGameObject(data) {
            for (let i = 0; i < data.length;) {
                objectManager.add(data[i], data[i + 1], data[i + 2], data[i + 3], data[i + 4],
                                  data[i + 5], items.list[data[i + 6]], true, (data[i + 7] >= 0 ? {
                    sid: data[i + 7]
                } : null));
                i += 8;
            }
        }

        // WIGGLE GAME OBJECT:
        function wiggleGameObject(dir, sid) {
            tmpObj = findObjectBySid(sid);
            if (tmpObj) {
                tmpObj.xWiggle += config.gatherWiggle * cos(dir);
                tmpObj.yWiggle += config.gatherWiggle * sin(dir);
            }
        }

        // SHOOT TURRET:
        function shootTurret(sid, dir) {
            tmpObj = findObjectBySid(sid);
            if (tmpObj) {
                tmpObj.dir = dir;
                tmpObj.xWiggle += config.gatherWiggle * cos(dir + pi);
                tmpObj.yWiggle += config.gatherWiggle * sin(dir + pi);
            }
        }

        // ADD PROJECTILE:
        function addProjectile(x, y, dir, range, speed, indx, layer, sid) {
            if (inWindow) {
                projectileManager.addProjectile(x, y, dir, range, speed, indx, null, null, layer).sid = sid;
            }
        }

        // REMOVE PROJECTILE:
        function remProjectile(sid, range) {
            for (let i = 0; i < projectiles.length; ++i) {
                if (projectiles[i].sid == sid) {
                    projectiles[i].range = range;
                }
            }
        }

        // ANIMATE AI:
        function animateAI(sid) {
            tmpObj = findAIBySID(sid);
            if (tmpObj) tmpObj.startAnim();
        }

        // ADD AI:
        function loadAI(data) {
            for (let i = 0; i < ais.length; ++i) {
                ais[i].forcePos = !ais[i].visible;
                ais[i].visible = false;
            }
            if (data) {
                var tmpTime = Date.now();
                for (let i = 0; i < data.length;) {
                    tmpObj = findAIBySID(data[i]);
                    if (tmpObj) {
                        tmpObj.index = data[i + 1];
                        tmpObj.t1 = (tmpObj.t2 === undefined) ? tmpTime : tmpObj.t2;
                        tmpObj.t2 = tmpTime;
                        tmpObj.x1 = tmpObj.x;
                        tmpObj.y1 = tmpObj.y;
                        tmpObj.x2 = data[i + 2];
                        tmpObj.y2 = data[i + 3];
                        tmpObj.d1 = (tmpObj.d2 === undefined) ? data[i + 4] : tmpObj.d2;
                        tmpObj.d2 = data[i + 4];
                        tmpObj.health = data[i + 5];
                        tmpObj.dt = 0;
                        tmpObj.visible = true;
                    } else {
                        tmpObj = aiManager.spawn(data[i + 2], data[i + 3], data[i + 4], data[i + 1]);
                        tmpObj.x2 = tmpObj.x;
                        tmpObj.y2 = tmpObj.y;
                        tmpObj.d2 = tmpObj.dir;
                        tmpObj.health = data[i + 5];
                        if (!aiManager.aiTypes[data[i + 1]].name) {
                            tmpObj.name = config.cowNames[data[i + 6]];
                        }
                        tmpObj.forcePos = true;
                        tmpObj.sid = data[i];
                        tmpObj.visible = true;
                    }
                    i += 7;
                }
            }
        }

        // RENDER AI:
        var aiSprites = {};

        function renderAI(obj, ctxt) {
            var tmpIndx = obj.index;
            var tmpSprite = aiSprites[tmpIndx];
            if (!tmpSprite) {
                var tmpImg = new Image();
                tmpImg.onload = function() {
                    this.isLoaded = true;
                    this.onload = null;
                };
                tmpImg.src = ".././img/animals/" + obj.src + ".png";
                tmpSprite = tmpImg;
                aiSprites[tmpIndx] = tmpSprite;
            }
            if (tmpSprite.isLoaded) {
                var tmpScale = obj.scale * 1.2 * (obj.spriteMlt || 1);
                ctxt.drawImage(tmpSprite, -tmpScale, -tmpScale, tmpScale * 2, tmpScale * 2);
            }
        }

        // OBJECT ON SCREEN:
        function isOnScreen(x, y, s) {
            return (x + s >= 0 && x - s <= maxScreenWidth && y + s >= 0 && y - s <= maxScreenHeight)
        }

        // ADD NEW PLAYER:
        function addPlayer(data, isYou) {
            var tmpPlayer = findPlayerByID(data[0]);
            if (!tmpPlayer) {
                tmpPlayer = new Player(data[0], data[1], config, Utils, projectileManager,
                                       objectManager, players, ais, items, hats, accessories);
                players.push(tmpPlayer);
            }
            tmpPlayer.spawn(isYou ? moofoll : null);
            tmpPlayer.visible = false;
            tmpPlayer.x2 = undefined;
            tmpPlayer.y2 = undefined;
            tmpPlayer.setData(data);
            if (isYou) {
                if (!player) {
                    prepareUI();
                }
                player = tmpPlayer;
                camX = player.x;
                camY = player.y;
                updateItems();
                updateStatusDisplay();
                updateAge();
                updateUpgrades(0);
                gameUI.style.display = "block";
            }
        }

        // REMOVE PLAYER:
        function removePlayer(id) {
            for (let i = 0; i < players.length; i++) {
                if (players[i].id == id) {
                    players.splice(i, 1);
                    break;
                }
            }
        }

        // UPDATE PLAYER ITEM VALUES:
        function updateItemCounts(index, value) {
            if (player) {
                player.itemCounts[index] = value;
            }
        }

        // UPDATE PLAYER VALUE:
        function updatePlayerValue(index, value, updateView) {
            if (player) {
                player[index] = value;
                if (index == "kills") {
                    let killsBox = getEl("kills_num");
                    let currentKills = parseInt(killsBox.innerText, 10);
                    let newKills = currentKills + 1;
                    killsBox.innerText = newKills.toString();
                } else if (index == "points") {
                    autoBuy.buyNext();
                }
                if (updateView) {
                    updateStatusDisplay();
                }
            }
        }

        // UPDATE HEALTH:
        function updateHealth(sid, value) {
            tmpObj = findPlayerBySID(sid);
            if (tmpObj) {
                tmpObj.health = value;
            }
        }
        let playtimeSeconds = 0;
        let timerIntervalc
        // UPDATE PLAYER DATA:
        function updatePlayers(data) {
            game.tick++;
            game.tickSpeed = performance.now() - game.lastTick;
            game.lastTick = performance.now();
            enemy = [];
            nears = [];
            players.forEach((tmp) => {
                tmp.forcePos = !tmp.visible;
                tmp.visible = false;
            });
            for (let i = 0; i < data.length;) {
                tmpObj = findPlayerBySID(data[i]);
                if (tmpObj) {
                    tmpObj.t1 = (tmpObj.t2 === undefined) ? game.lastTick : tmpObj.t2;
                    tmpObj.t2 = game.lastTick;
                    tmpObj.x1 = tmpObj.x;
                    tmpObj.y1 = tmpObj.y;
                    tmpObj.x2 = data[i + 1];
                    tmpObj.y2 = data[i + 2];
                    tmpObj.d1 = (tmpObj.d2 === undefined) ? data[i + 3] : tmpObj.d2;
                    tmpObj.d2 = data[i + 3];
                    tmpObj.dt = 0;
                    tmpObj.buildIndex = data[i + 4];
                    tmpObj.weaponIndex = data[i + 5];
                    tmpObj.weaponVariant = data[i + 6];
                    tmpObj.team = data[i + 7];
                    tmpObj.isLeader = data[i + 8];
                    tmpObj.skinIndex = data[i + 9];
                    tmpObj.tailIndex = data[i + 10];
                    tmpObj.iconIndex = data[i + 11];
                    tmpObj.zIndex = data[i + 12];
                    tmpObj.visible = true;
                    tmpObj.update(game.tickSpeed);
                    if (!tmpObj.isTeam(player)) {
                        enemy.push(tmpObj);
                        if (tmpObj.dist2 <= items.weapons[tmpObj.primaryIndex == undefined ? 5 : tmpObj.primaryIndex].range + player.scale * 1.8 + 69) {
                            nears.push(tmpObj);
                        }
                    }
                  /*  tmpObj.manageReload();
                    if (tmpObj != player) {
                        tmpObj.addDamageThreat(player);
                    }*/
                }
                i += 13;
            }
            if (player && player.alive) {
                if (enemy.length) {
                    near = enemy.sort(function (tmp1, tmp2) {
                        return tmp1.dist2 - tmp2.dist2;
                    })[0];
                }
                if (game.tickQueue[game.tick]) {
                    game.tickQueue[game.tick].forEach((action) => {
                        action();
                    });
                    game.tickQueue[game.tick] = null;
                }
                players.forEach((tmp) => {
                    if (!tmp.visible && player != tmp) {
                        tmp.reloads = {
                            0: 0,
                            1: 0,
                            2: 0,
                            3: 0,
                            4: 0,
                            5: 0,
                            6: 0,
                            7: 0,
                            8: 0,
                            9: 0,
                            10: 0,
                            11: 0,
                            12: 0,
                            13: 0,
                            14: 0,
                            15: 0,
                            53: 0,
                        };
                    }
                });
            }
            if (inGame) {
                sendMoveDir();
                if (!timerIntervalc) {
                    timerIntervalc = setInterval(function() {
                        playtimeSeconds++;
                        let hours = floor(playtimeSeconds / 3600);
                        let minutes = floor((playtimeSeconds % 3600) / 60);
                        let seconds = playtimeSeconds % 60;
                        let formattedPlaytime = `${hours > 0 ? String(hours).padStart(2, '0') : ''}${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                        getEl("playtime").innerText = formattedPlaytime;
                    }, 889);
                }
                macro.q && place(0, getAttackDir());
                macro.f && place(4, getAttackDir());
                macro.v && place(2, getAttackDir());
                macro.y && place(5, getAttackDir());
                macro.h && place(player.getItemType(22), getAttackDir());
                macro.n && place(3, getAttackDir());
                if (mills.place) {
                    if (Utils.getDist(mills.old, player, 0, 2) > 99) {
                        let placeAngle = player.items[4] == 16 ? 1.4 : 1.23456789
                        Cplace(3, -placeAngle, placeAngle, placeAngle, Utils.getDirect(mills.old, player, 0, 2))
                        mills.old = {
                            x: player.x2,
                            y: player.y2
                        }
                    }
                }
                if (mills.placeSpawnPads) {
                    if (Utils.getDist(mills.old, player, 0, 2) > 125) {
                        Cplace(player.getItemType(20), 0, pi*1.5, pi_2, Utils.getDirect(mills.old, player, 0, 2))
                        mills.old = {
                            x: player.x2,
                            y: player.y2
                        }
                    }
                }
                if (my.stopBreak && autoGathering) {
                    sendAutoGather();
                } else {
                    if (!clicks.middle && !clicks.left && !clicks.right /*&& !instaC.isTrue*/ && !autoBreak.active && autoGathering) {
                        sendAutoGather();
                    }
                    if (!clicks.middle && (clicks.left || clicks.right)/* && !instaC.isTrue*/) {
                        if ((player.weaponIndex != (clicks.right && autoBreak.useHammer() ? player.weapons[1] : player.weapons[0])) || player.buildIndex > -1) {
                            selectWeapon(clicks.right && autoBreak.useHammer() ? player.weapons[1] : player.weapons[0]);
                        }
                        if (player.reloads[clicks.right && autoBreak.useHammer() ? player.weapons[1] : player.weapons[0]] <= window.pingTime/2 && !my.waitHit && !autoGathering) {
                            sendAutoGather();
                            my.waitHit = 1;
                            game.tickBase(() => {
                                my.waitHit = 0
                            }, 1)
                        }
                    }
                    if (autoBreak.active) {
                        if (!clicks.left && !clicks.right /*&& !instaC.isTrue*/) {
                            let weapon = autoBreak.useHammer(autoBreak.target) ? player.weapons[1] : player.weapons[0];
                            if (player.weaponIndex != weapon || player.buildIndex > -1) {
                                selectWeapon(weapon);
                            }
                            if (player.reloads[weapon] <= window.pingTime/2 && !my.waitHit && !autoGathering) {
                                sendAutoGather();
                                my.waitHit = 1;
                                game.tickBase(() => {
                                    my.waitHit = 0;
                                }, 1)
                            }
                        }
                    }
                }

                if (player.weapons[1] && !clicks.left && !clicks.right && !player.inTrap/* && !instaC.isTrue*/ && !autoBreak.active) {
                    if (player.reloads[player.weapons[0]] <= window.pingTime/2 && player.reloads[player.weapons[1]] <= window.pingTime/2) {
                        if (!my.reloaded) {
                            my.reloaded = true;
                            let fastSpeed = items.weapons[player.weapons[0]].spdMult < items.weapons[player.weapons[1]].spdMult ? 1 : 0;
                            if (player.weaponIndex != player.weapons[fastSpeed] || player.buildIndex > -1) {
                                selectWeapon(player.weapons[fastSpeed]);
                            }
                        }
                    } else {
                        my.reloaded = false;
                        if (player.reloads[player.weapons[0]] > 0) {
                            if (player.weaponIndex != player.weapons[0] || player.buildIndex > -1) {
                                selectWeapon(player.weapons[0]);
                            }
                        } else if (player.reloads[player.weapons[1]] > 0) {
                            if (player.weaponIndex != player.weapons[1] || player.buildIndex > -1) {
                                selectWeapon(player.weapons[1]);
                            }
                        }
                    }
                }

                // AutoHatsOMG
                    if (storeMenu.style.display != "block") HatAcc.auto();

            }
        }


        // PING:
        var lastPing = -1;

        function pingSocketResponse() {
            var pingTime = Date.now() - lastPing;
            window.pingTime = pingTime;
            pingDisplay.innerText = "Ping: " + pingTime + " ms"
        }

        function pingSocket() {
            lastPing = Date.now();
            io.send("ping", "0");
        }

        // SERVER SHUTDOWN NOTICE:
        function serverShutdownNotice(countdown) {
            if (countdown < 0) return;

            var minutes = floor(countdown / 60);
            var seconds = countdown % 60;
            seconds = ("0" + seconds).slice(-2);

            shutdownDisplay.innerText = "Server restarting in " + minutes + ":" + seconds;
            shutdownDisplay.hidden = false;
        }

        // START GAME:
        function startGame() {
            bindEvents();
            loadIcons();
            loadingText.style.display = "none";
            menuCardHolder.style.display = "block";
            nameInput.value = getSavedVal("moo_name") || "";
        }
        prepareMenuBackground();
        function doUpdate() {
            now = Date.now();
            delta = now - lastUpdate;
            lastUpdate = now;
            updateGame();
            window.requestAnimFrame(doUpdate);
        };
        doUpdate();
        window.requestAnimFrame = (function() {
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame ||
                function(callback) {
                window.setTimeout(callback, 1000 / 60);
            };
        })();
        class VultrLite { // im using this since i SPENT 2 HOUR on THAT STUPID VULTRCLIENT JUST TO GET NOTHING
            constructor(apiUrl) {
                this.apiUrl = apiUrl || "https://api-sandbox.moomoo.io/servers";
                this.servers = [];
                this.regionsName = {
                    "eu-west": "Frankfurt",
                    gb: "London",
                    "us-east": "Miami",
                    "us-west": "Silicon Valley",
                    au: "Sydney",
                    sg: "Singapore",
                    saopaulo: "So Paulo"
                };
            }
            async getServers() {
                try {
                    const response = await fetch(this.apiUrl);
                    this.servers = await response.json();
                    await Promise.all(
                        this.servers.map(async server => {
                            let pingUrl = `https://${server.key}.${server.region}.moomoo.io/ping/`;
                            let startTime = Date.now();
                            try {
                                await fetch(pingUrl);
                                server.ping = Date.now() - startTime;
                            } catch (error) {
                                server.ping = Infinity;
                            }
                        })
                    );

                    return this.servers;
                } catch (error) {
                    console.error("Error fetching servers:", error);
                    return [];
                }
            }
            sortServers(servers) {
                return servers.sort((a, b) => {
                    if (a.ping === b.ping) return b.playerCount - a.playerCount;
                    return a.ping - b.ping;
                });
            }
            formatServer(server) {
                return {
                    region: this.regionsName[server.region] || server.region,
                    name: server.name,
                    ping: server.ping,
                    playerCount: server.playerCount,
                    playerCapacity: server.playerCapacity
                };
            }
        }
        var vultrLite = new VultrLite();
        UI.addStyle('tempoMenuStyle', `
    #tempo_menu1 {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        z-index: 10000;
        display: flex;
        flex-direction: column;
    }

    #tempo_menu1_header {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 5px 20px;
        height: 40px;
        background-color: rgba(0, 0, 0, 0.8);
    }

    #profile {
        display: flex;
        align-items: center;
        margin-right: auto;
    }

    #profile img {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        margin-right: 10px;
    }

    #tempo_menu1_content {
        display: flex;
        flex-direction: column;
        padding: 10px;
        margin-top: 20px;
    }

    .menu_item1, .longM1 {
        padding: 15px;
        background-color: rgba(0, 0, 0, 0.5);
        margin: 5px 0;
        border-radius: 20px;
        width: 15%;
        margin-left: 1%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }

    .longM1 {
      height: 500px;
        width: 15%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    position: absolute;
    top: 21.4%;
}

.infoBox {
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 20px;
    width: 70%;
    margin: 10px 0;
    padding: 10px;
    text-align: center;
}

.infoBoxTitle {
    font-size: 18px;
    font-weight: bold;
    color: white;
    margin-bottom: 5px;
}

.infoBoxValue {
    font-size: 24px;
    color: white;
    font-weight: bold;
}

    .progress-bar {
        width: 100%;
        height: 12px;
        background-color: gray;
        margin-top: 10px;
        border-radius: 5px;
    }

    .progress {
        height: 100%;
        background: linear-gradient(to right, black, white);
        border-radius: 5px;
    }
.bigM1 {
    padding: 15px;
    background-color: rgba(0, 0, 0, 0.5);
    margin: 5px 0;
    border-radius: 20px;
    height: 600px;
    width: 30%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    position: absolute;
    left: 20%;
    overflow-y: auto;
    -ms-overflow-style: none;
    scrollbar-width: none;
}

.bigM1::-webkit-scrollbar {
    display: none;
}

.serverListContainer {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
}
.menu_item2 {
    height: 100%;
    background-color: rgba(255, 255, 255, 0.1);
    margin: 5px 0;
    border-radius: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
}

.menu_item2:hover {
    background-color: rgba(0, 0, 0, 0.6);
    cursor: pointer;
}

.menu_item2 div {
    color: white;
    font-size: 14px;
    text-align: center;
}
.serverListContainer > div:first-child {
    font-size: 20px;
    font-weight: bold;
    margin-bottom: 10px;
    text-align: center;
    color: white;
}


    .smallM1 {
        padding: 15px;
        background-color: rgba(0, 0, 0, 0.5);
        margin: 5px 0;
        border-radius: 20px;
        height: 100px;
        width: 25%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: absolute;
        left: 53%;
        font-size: 55px;
        font-weight: bold;
        text-align: center;
        color: white;
        text-shadow: 0 0 10px rgba(255, 255, 255, 1), 0 0 20px rgba(0, 0, 255, 1), 0 0 30px rgba(0, 0, 255, 1);
    }

    .smallM2 {
        padding: 15px;
        background-color: rgba(0, 0, 0, 0.5);
        margin: 5px 0;
        border-radius: 20px;
        height: 50px;
        width: 25%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: absolute;
        top: 230px;
        left: 53%;
    }
.smallM3 {
    padding: 15px;
    background-color: rgba(0, 0, 0, 0.4);
    margin: 5px 0;
    border-radius: 20px;
    height: 50px;
    width: 10%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 330px;
    left: 53%;
    cursor: pointer;
    color: white;
    font-size: 20px;
    font-weight: bold;
    text-align: center;
    box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.4);
}

.smallM3:hover {
    background-color: rgba(0, 0, 0, 0.4);
    box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.1);
}


    .smallM4 {
        padding: 15px;
        background-color: rgba(0, 0, 0, 0.5);
        margin: 5px 0;
        border-radius: 20px;
        height: 50px;
        width: 10%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: absolute;
        top: 330px;
        left: 68%;
    }

    .timer {
        font-size: 20px;
        margin-bottom: 10px;
    }
   .smallM5 {
    padding: 15px;
    background-color: rgba(0, 0, 0, 0.5);
    margin: 5px 0;
    border-radius: 20px;
    height: 230px;
    width: 25%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    position: absolute;
    top: 450px;
    left: 53%;
}

.updateTitle {
    font-size: 25px;
    font-weight: bold;
    color: white;
    text-align: center;
    margin-bottom: 10px;
}

.logBox {
    width: 100%;
    height: 150px;
    background-color: rgba(0, 0, 0, 0);
    color: white;
    padding: 10px;
    border-radius: 10px;
    overflow-y: auto;
    font-size: 20px;
}


.longM2 {
    background-color: rgba(0, 0, 0, 0.5);
    margin: 5px 0;
    border-radius: 20px;
    height: 100px;
    width: 2.8%;
    height: 75%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 76px;
    left: 80.5%;
}
.skinColorSelector {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        width: 100%;
    }
.skinColorCircle {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin: 5px;
    cursor: pointer;
    border: 2px solid #fff;
}

.skinColorCircle:hover {
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
}

`);
        const tempo_container = document.createElement('div');
        tempo_container.id = 'tempo_menu1';
        document.body.appendChild(tempo_container);
        UI.InnerHtml('tempo_menu1', (ui) => {
            ui.append('<div id="tempo_menu1_header">');
            // for future use
            ui.append(`
     <div id="profile">
            <img id="userAvatar" src="" alt="Profile" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
            <span id="userName" style="font-size: 16px;">Enter your ID</span>
        </div>
    `);
            ui.append('</div>');

            ui.append('<div id="tempo_menu1_content">');
            ui.append(`
    <div class="menu_item1">
        <div id="timer" class="timer">Loading...</div>
        <div class="progress-bar">
            <div id="progress" class="progress"></div>
        </div>
    </div>
      <div class="longM1">
            <div class="infoBox">
                <div class="infoBoxTitle">Kills</div>
                <div class="infoBoxValue" id="kills_num">0</div>
            </div>
            <div class="infoBox">
                <div class="infoBoxTitle">Deaths</div>
                <div class="infoBoxValue" id="deaths">0</div>
            </div>
             <div class="infoBox">
                <div class="infoBoxTitle">Key</div>
                <div class="infoBoxValue" id="key_num">0</div>
            </div>
             <div class="infoBox">
                <div class="infoBoxTitle">Used The Mod</div>
                <div class="infoBoxValue" id="HowmANy">0</div>
            </div>
            <div class="infoBox">
                <div class="infoBoxTitle">Playtime</div>
                <div class="infoBoxValue" id="playtime">00:00</div>
            </div>
        </div>
    <div class="bigM1"></div>
    <div class="smallM1">Robotics v1.8</div>
    <div class="smallM2">
        <input type="text" id="nameInput" placeholder="Enter your name" style="width: 90%; padding: 5px; border-radius: 5px; border: none; color: black; margin-top: 10px; border-radius: 20px; background-color: rgba(0, 0, 0, 0); color: white;">
    </div>
    <div class="smallM3" id="enterButton">
        <span style="color: white; font-size: 20px; font-weight: bold;">Enter</span>
    </div>
    <div class="smallM4">
    </div>
    <div class="smallM5">
    <div class="updateTitle">Update 1.8</div>
    <div class="logBox">
     <div>New Bundle / More Work can be Done here :P</div>
     <div>New MainMenu / Made By yurio</div>
    </div>
    </div>
    <div class="longM2" id="skinColorSelector">

    </div>
    `);
            ui.append('</div>');
        });
        let skinColorSelector = getEl('skinColorSelector');
        let skinColorWrapper = document.createElement('div');
        skinColorWrapper.classList.add('skinColorSelector');
        skinColorSelector.appendChild(skinColorWrapper);
        config.skinColors.forEach((color, index) => {
            let circle = document.createElement('div');
            circle.classList.add('skinColorCircle');
            circle.style.backgroundColor = color;
            circle.addEventListener('click', () => {
                skinColor = color
            });
            skinColorWrapper.appendChild(circle);
        });
        let totalTime = parseInt(localStorage.getItem('tempo_timeLeft')) || 0;
        let timeLeft = totalTime;
        let keyCount = parseInt(localStorage.getItem('keyCount')) || 0;
        let tempo_name = localStorage.getItem('tempo_name') || '';
        let progressBar = getEl('progress');
        let timerDisplay = getEl('timer');

        function formatTime(timeInSeconds) {
            let days = floor(timeInSeconds / 86400);
            let hours = floor((timeInSeconds % 86400) / 3600);
            let minutes = floor((timeInSeconds % 3600) / 60);
            let seconds = timeInSeconds % 60;

            if (days > 0) {
                return `${days}D ${hours}H ${minutes}M ${seconds}s`;
            } else if (hours > 0) {
                return `${hours}H ${minutes}M ${seconds}s`;
            } else if (minutes > 0) {
                return `${minutes}M ${seconds}s`;
            } else {
                return `${seconds}s`;
            }
        }

        function updateProgressBar() {
            let progressPercentage = (timeLeft / totalTime) * 100;
            progressBar.style.width = `${progressPercentage}%`;
        }

        function updateKeyDisplay() {
            let keyElement = getEl('key_num');
            if (keyElement) {
                keyElement.innerText = keyCount;
            }
        }

        function useKey() {
            if (keyCount > 0) {
                if (confirm("Use 1 key to add 1 hour of playtime?")) {
                    keyCount--;
                    localStorage.setItem('keyCount', keyCount);
                    updateKeyDisplay();

                    timeLeft += 3600;
                    totalTime = timeLeft;
                    localStorage.setItem('tempo_timeLeft', timeLeft);
                    alert("1 hour added to your playtime!");
                }
            } else {
                alert("You don't have any keys! Please acquire a key to continue.");
            }
        }

        function updateTimer() {
            if (timeLeft > 0) {
                timeLeft--;
                timerDisplay.innerHTML = `${formatTime(timeLeft)}`;
                updateProgressBar();
                localStorage.setItem('tempo_timeLeft', timeLeft);
            } else {
                clearInterval(timerInterval);
                timerDisplay.innerHTML = 'Key Expired!';

                setTimeout(() => {
                    if (confirm("Your playtime has expired. Use a key to add more time?")) {
                        useKey();
                        if (timeLeft > 0) {
                            timerInterval = setInterval(updateTimer, 1000);
                        }
                    } else {
                        alert("Thank you for playing. Please come back with a key!");
                    }
                }, 1000);
            }
        }

        let timerInterval = setInterval(updateTimer, 1000);

        document.getElementById('nameInput').value = tempo_name;
        getEl('enterButton').addEventListener('click', () => {
            let name = getEl('nameInput').value;
            if (name) {
                tempo_name = name;
                localStorage.setItem('tempo_name', tempo_name);
            }
            if (mainMenuM.firstLoad === false) {
                if (keyCount > 0 && timeLeft <= 0) {
                    if (confirm("Use 1 key to play? This will decrease your key count by 1.")) {
                        keyCount--;
                        localStorage.setItem('keyCount', keyCount);
                        updateKeyDisplay();

                        timeLeft += 3600;
                        totalTime = timeLeft;
                        localStorage.setItem('tempo_timeLeft', timeLeft);
                        updateProgressBar();
                    }
                } else if (timeLeft > 0) {
                    connectSocket();
                } else {
                    alert("You don't have any keys! Please acquire a key to play.");
                }
            } else {
                enterGame();
            }
        });


        updateKeyDisplay();
        updateProgressBar();


        async function renderServerList() {
            let bigM1 = document.querySelector('.bigM1');
            let serverListContainer = document.createElement('div');
            serverListContainer.classList.add('serverListContainer');
            let serverListTitle = document.createElement('div');
            serverListTitle.innerText = 'Server List';
            serverListTitle.style.fontSize = '20px';
            serverListTitle.style.fontWeight = 'bold';
            serverListTitle.style.marginBottom = '10px';
            serverListTitle.style.color = 'white';
            serverListTitle.style.textAlign = 'center';
            serverListContainer.appendChild(serverListTitle);
            let servers = await vultrLite.getServers();
            servers.sort((a, b) => a.ping - b.ping);
            servers.forEach(server => {
                let serverItem = document.createElement('div');
                serverItem.classList.add('menu_item2');
                serverItem.style.width = '100%';
                let serverName = document.createElement('div');
                serverName.innerText = `Server: ${vultrLite.formatServer(server).region} ${server.name}`;
                serverName.style.fontSize = '16px';
                serverName.style.fontWeight = 'bold';
                let serverPing = document.createElement('div');
                let pingValue = server.ping !== Infinity ? server.ping : 'N/A';
                let pingText = `Ping: ${pingValue === 'N/A' ? pingValue : pingValue + ' ms'}`;
                serverPing.innerText = pingText;
                serverPing.style.fontSize = '14px';
                if (server.ping !== Infinity) {
                    let pingNumber = pingValue;
                    let pingNumberText = pingValue + ' ms';
                    let pingParts = pingNumberText.split(' ');
                    let pingNumberElement = document.createElement('span');
                    pingNumberElement.innerText = pingParts[0];
                    if (pingNumber > 500) {
                        pingNumberElement.style.color = 'red';
                    } else if (pingNumber <= 80) {
                        pingNumberElement.style.color = 'green';
                    } else if (pingNumber > 80 && pingNumber <= 200) {
                        pingNumberElement.style.color = 'orange';
                    } else {
                        pingNumberElement.style.color = 'yellow';
                    }
                    serverPing.innerHTML = `Ping: `;
                    serverPing.appendChild(pingNumberElement);
                    serverPing.innerHTML += ' ms';
                }
                let serverPlayers = document.createElement('div');
                serverPlayers.innerText = `Players: ${server.playerCount}/${server.playerCapacity}`;
                serverPlayers.style.fontSize = '14px';
                serverItem.appendChild(serverName);
                serverItem.appendChild(serverPing);
                serverItem.appendChild(serverPlayers);
                serverItem.addEventListener('click', () => {
                    let newUrl = `${location.protocol}//${location.hostname}/?server=${server.region}:${server.name}`;
                    window.location.href = newUrl;
                });
                serverListContainer.appendChild(serverItem);
            });

            bigM1.appendChild(serverListContainer);
        }

        setTimeout(3000, renderServerList);
        renderServerList();
        // MUAWHAHA
        let usedModCount = localStorage.getItem('usedModCount');
        if (usedModCount === null) {
            usedModCount = 0;
        } else {
            usedModCount = parseInt(usedModCount);
        }
        usedModCount++;
        localStorage.setItem('usedModCount', usedModCount);
        getEl('HowmANy').innerText = usedModCount;


        // Connect Socket
        async function connectSocket() {
            try {
                vultrClient.start(t => {
                    let wsAddress = `wss://${t}`;
                    if (AltchaToken != "" || AltchaToken != undefined) {
                        wsAddress += `/?token=${AltchaToken}`;
                    }
                    io.connect(wsAddress, function(error) {
                        pingSocket();
                        setInterval(() => pingSocket(), 2500);
                        if (error) {
                            disconnect(error);
                        } else {
                            connected = true;
                            startGame();
                            io.connected = true;
                            enterGame();
                            Utils.hookTouchEvents(enterGameButton);
                        }
                    }, {
                        "A": setInitData,
                        "B": disconnect,
                        "C": setupGame,
                        "D": addPlayer,
                        "E": removePlayer,
                        "a": updatePlayers,
                        "G": updateLeaderboard,
                        "H": loadGameObject,
                        "I": loadAI,
                        "J": animateAI,
                        "K": gatherAnimation,
                        "L": wiggleGameObject,
                        "M": shootTurret,
                        "N": updatePlayerValue,
                        "O": updateHealth,
                        "P": killPlayer,
                        "Q": killObject,
                        "R": killObjects,
                        "S": updateItemCounts,
                        "T": updateAge,
                        "U": updateUpgrades,
                        "V": updateItems,
                        "X": addProjectile,
                        "Y": remProjectile,
                        "Z": serverShutdownNotice,
                        "g": addAlliance,
                        "1": deleteAlliance,
                        "2": allianceNotification,
                        "3": setPlayerTeam,
                        "4": setAlliancePlayers,
                        "5": updateStoreItems,
                        "6": receiveChat,
                        "7": updateMinimap,
                        "8": showText,
                        "9": pingMap,
                        "0": pingSocketResponse
                    });
                }, error => {
                    console.error("Vultr Error:", error);
                });
            } catch (error) {
                console.error("ERROR IN SOCKET:", error);
            }
        }
    },
    client: {
        vultrClient: class {
            constructor(baseUrl, devPort, lobbySize, lobbySpread, rawIPs) {
                this.debugLog = false;
                this.baseUrl = baseUrl;
                this.lobbySize = lobbySize;
                this.devPort = devPort;
                this.lobbySpread = lobbySpread;
                this.rawIPs = !!rawIPs;
                this.server = undefined;
                this.gameIndex = undefined;
                this.callback = undefined;
                this.errorCallback = undefined;
            }

            static regionInfo = {
                0: {
                    name: "Local",
                    latitude: 0, longitude: 0
                },
                "us-east": {
                    name: "Miami",
                    latitude: 40.1393329, longitude: -75.8521818
                },
                miami: {
                    name: "Miami",
                    latitude: 40.1393329, longitude: -75.8521818 },
                "us-west": {
                    name: "Silicon Valley",
                    latitude: 47.6149942, longitude: -122.4759879 },
                siliconvalley: {
                    name: "Silicon Valley",
                    latitude: 47.6149942, longitude: -122.4759879 },
                gb: {
                    name: "London",
                    latitude: 51.5283063, longitude: -0.382486 },
                london: {
                    name: "London",
                    latitude: 51.5283063, longitude: -0.382486 },
                "eu-west": {
                    name: "Frankfurt",
                    latitude: 50.1211273, longitude: 8.496137 },
                frankfurt: {
                    name: "Frankfurt",
                    latitude: 50.1211273, longitude: 8.496137 },
                au: {
                    name: "Sydney",
                    latitude: -33.8479715, longitude: 150.651084 },
                sydney: {
                    name: "Sydney",
                    latitude: -33.8479715, longitude: 150.651084 },
                saopaulo: {
                    name: "So Paulo",
                    latitude: 23.5558, longitude: 46.6396 },
                sg: {
                    name: "Singapore",
                    latitude: 1.3147268, longitude: 103.7065876 },
                singapore: {
                    name: "Singapore",
                    latitude: 1.3147268,
                    longitude: 103.7065876 }
            };

            log(message) {
                if (this.debugLog) {
                    console.log(message);
                }
            }

            start(callback, errorCallback) {
                this.callback = callback;
                this.errorCallback = errorCallback;
                let serverInfo = this.parseServerQuery();
                console.log("current server Info:", serverInfo);
                if (serverInfo && serverInfo.length > 0) {
                    console.log("Found server in query.");
                    this.password = serverInfo[3];
                    this.connect(serverInfo[0], serverInfo[1], serverInfo[2]);
                } else {
                    this.errorCallback("Unable to find server");
                }
            }

            parseServerQuery(query) {
                let params = new URLSearchParams(location.search);
                let server = query || params.get("server");

                if (typeof server !== "string") return [];

                let [region, name] = server.split(":");
                return [region, name, params.get("password")];
            }

            findServer(region, serverName) {
                let regionServers = this.servers[region];

                for (let i = 0; i < regionServers.length; i++) {
                    let server = regionServers[i];
                    if (server.name === serverName) return server;
                }

                console.warn(`Could not find server in region ${region} with serverName ${serverName}.`);
            }

            seekServer(region, prioritizeEmpty = false, serverKey = "random") {
                let availableServers = this.servers[region]
                .flatMap((serverGroup) => {
                    let gameIndex = 0;
                    return serverGroup.games.map((game) => {
                        let index = gameIndex++;
                        return {
                            region: serverGroup.region,
                            index: serverGroup.index * serverGroup.games.length + index,
                            gameIndex: index,
                            gameCount: serverGroup.games.length,
                            playerCount: game.playerCount,
                            playerCapacity: game.playerCapacity,
                            isPrivate: game.isPrivate
                        };
                    });
                })
                .filter((game) => !game.isPrivate)
                .filter((game) => prioritizeEmpty ? game.playerCount === 0 && game.gameIndex >= game.gameCount / 2 : true)
                .filter((game) => serverKey === "random" ? true : game.index % serverKey.length === 0)
                .sort((a, b) => b.playerCount - a.playerCount)
                .filter((game) => game.playerCount < this.lobbySize);

                if (prioritizeEmpty) availableServers.reverse();

                if (availableServers.length === 0) {
                    this.errorCallback("No open servers.");
                    return;
                }

                let randomIndex = min(this.lobbySpread, availableServers.length);
                let selectedServer = availableServers[floor(random() * randomIndex)];

                let serverRegion = selectedServer.region;
                let groupIndex = floor(selectedServer.index / selectedServer.gameCount);
                let gameIndex = selectedServer.index % selectedServer.gameCount;

                this.log("Found server.");
                return [serverRegion, groupIndex, gameIndex];
            }

            connect(region, serverName, gameIndex) {
                if (this.connected) return;

                let server = this.findServer(region, serverName);
                if (!server) {
                    this.errorCallback(`Failed to find server for region ${region} and serverName ${serverName}`);
                    return;
                }

                this.log("Connecting to server", server, "with game index", gameIndex);

                if (server.playerCount >= server.playerCapacity) {
                    this.errorCallback("Server is already full.");
                    return;
                }

                window.history.replaceState(document.title, document.title, this.generateHref(region, serverName, this.password));
                this.server = server;
                this.gameIndex = gameIndex;

                this.log("Calling callback with address", this.serverAddress(server), "on port", this.serverPort(server));
                this.callback(this.serverAddress(server), this.serverPort(server), gameIndex);

                if (this.connectionInterval) clearInterval(this.connectionInterval);
            }

            generateHref(region, serverName, password) {
                let href = window.location.href.split("?")[0];
                href += `?server=${region}:${serverName}`;
                if (password) href += `&password=${encodeURIComponent(password)}`;
                return href;
            }

            serverAddress(server) {
                return server.region === 0 ? "localhost" : `${server.key}.${server.region}.${this.baseUrl}`;
            }

            serverPort(server) {
                return server.port;
            }

            async processServers(servers) {
                if (this.connectionInterval) clearInterval(this.connectionInterval);

                let regions = {};

                servers.forEach((server) => {
                    let regionKey = server.region;
                    if (!regions[regionKey]) regions[regionKey] = [];
                    regions[regionKey].push(server);
                });

                let fetchRegionServers = async () => {
                    await Promise.all(Object.keys(regions).map(async (regionKey) => {
                        let regionServers = regions[regionKey];
                        let firstServer = regionServers[0];
                        let serverAddress = this.serverAddress(firstServer);
                        let port = this.serverPort(firstServer);
                        if (port) serverAddress += `:${port}`;
                        let pingUrl = `https://${serverAddress}/ping`;
                        let startTime = Date.now();
                        await Promise.race([
                            fetch(pingUrl)
                            .then(() => {
                                let pingTime = Date.now() - startTime;
                                regionServers.forEach((server) => {
                                    server.pings = server.pings || [];
                                    server.pings.push(pingTime);
                                    if (server.pings.length > 10) server.pings.shift();
                                    server.ping = floor(server.pings.reduce((sum, ping) => sum + ping, 0) / server.pings.length);
                                });
                            })
                            .catch(() => { }),
                            new Promise((resolve) => setTimeout(resolve, 100))
                        ]);
                    }));
                };

                await fetchRegionServers();

                Object.values(regions).forEach((servers) => {
                    servers.sort((a, b) => (a.ping || Infinity) - (b.ping || Infinity));
                });

                this.servers = regions;
                let selectedServer;
                const [queryRegion, queryName] = this.parseServerQuery();
                servers.forEach((server) => {
                    if (queryRegion === server.region && queryName === server.name) {
                        server.selected = true;
                        selectedServer = server;
                    }
                });
                return this.servers
                this.log("Processed servers:", regions);
            }
        },
        io: {
            socket: undefined,
            socketID: true,
            connected: false,
            errors: [],
            socketError: false,
            debug: false,
            packets: [
                {
                    type: "move",
                    pac: ["33", "a", "f"],
                    changeTo: "9",
                },
                {
                    type: "chat",
                    pac: ["ch", "fh"],
                    changeTo: "6",
                },
                {
                    type: "gather",
                    pac: ["7"],
                    changeTo: "K",
                },
                {
                    type: "attack",
                    pac: ["c", "d"],
                    changeTo: "F",
                },
                {
                    type: "dir",
                    pac: ["2"],
                    changeTo: "D",
                },
                {
                    type: "spawn",
                    pac: ["sp"],
                    changeTo: "M",
                },
                {
                    type: "ping",
                    pac: ["pp"],
                    changeTo: "0",
                },
                {
                    type: "hatAccs",
                    pac: ["13c"],
                    changeTo: "c",
                },
                {
                    type: "upgrade",
                    pac: ["6"],
                    changeTo: "H",
                },
                {
                    type: "select",
                    pac: ["5", "G"],
                    changeTo: "z",
                },
                {
                    type: "join_clan",
                    pac: ["10"],
                    changeTo: "b",
                },
                {
                    type: "leave_clan",
                    pac: ["9"],
                    changeTo: "N",
                },
                {
                    type: "create_clan",
                    pac: ["8"],
                    changeTo: "L",
                },
                {
                    type: "kick_clan",
                    pac: ["12"],
                    changeTo: "Q",
                },
                {
                    type: "ajoin_req",
                    pac: ["11"],
                    changeTo: "P",
                },
                {
                    type: "reset",
                    pac: ["rmd"],
                    changeTo: "e",
                },
            ],
            events: {},

            log: function (message, type = "info") {
                if (this.debug) {
                    console[type](message);
                }
            },

            connect: function (server, callback, events) {
                let msgpack = Moddo.msgpack;
                this.server = server;
                this.callback = callback;
                this.events = events;

                this.socket = new WebSocket(server);
                this.socket.binaryType = "arraybuffer";

                this.socket.onmessage = (message) => {
                    var data = new Uint8Array(message.data);
                    var parsed = msgpack.decode(data);
                    var type = parsed[0];
                    data = parsed[1];
                    if (type === "io-init") {
                        this.socketId = data[0];
                    } else {
                        if (events[type]) {
                            events[type].apply(undefined, data);
                        }
                    }
                };

                this.socket.onopen = () => {
                    this.connected = true;
                    this.log("Connected to server");
                    if (callback) callback();
                };

                this.socket.onclose = (event) => {
                    this.connected = false;
                    this.log(`Socket closed with code: ${event.code}`, "warn");
                };

                this.socket.onerror = (error) => {
                    this.socketError = true;
                    this.log("Socket error", "error");
                };
            },

            socketReady: function () {
                return this.socket && this.connected;
            },

            disconnect: function (reason) {
                if (this.socket) {
                    this.socket.close();
                    this.log(reason, "warn");
                }
            },

            send: function (type, packetCode) {
                let msgpack = Moddo.msgpack;
                this.log(`type:"${type}", Pac:"${packetCode}"`);
                let packet = this.packets.find((p) => p.type === type);
                if (!packet) {
                    this.log(`Invalid packet type: ${type}`, "error");
                    return;
                }
                if (packet.pac.includes(packetCode) || packet.changeTo == packetCode) {
                    if (typeof packet.changeTo === "string") {
                        let data = Array.prototype.slice.call(arguments, 2);
                        let binary = msgpack.encode([packet.changeTo, data]);
                        this.socket.send(binary);
                    }
                } else {
                    this.log(`Packet: ${packetCode}, type: ${type}`, "error");
                }
            },
        },
    },
    modules: {
        AnimText: class {
            constructor(x, y, value, type, scale, color, index) {
                this.x = x;
                this.y = y;
                this.value = value;
                this.type = type;
                this.scale = scale;
                this.color = color;
                this.index = index;
                this.alpha = 0;
                this.maxTime = 1300;
                this.time = this.maxTime;
                this.shaking = Moddo.modules.Utils.randFloat(-1, 1);
                this.accelerate = 1;
            }

            update(delta) {
                this.x += this.shaking;
                this.y -= (delta / 10) * this.accelerate;

                if (this.time < this.maxTime / 2) {
                    if (this.alpha > 0) {
                        this.alpha = max(0, this.alpha - (delta / (this.maxTime / 2.5)));
                    }
                } else {
                    if (this.alpha < 1) {
                        this.alpha = min(1, this.alpha + (delta / 100));
                    }
                }

                this.accelerate -= delta / (this.maxTime / 2.5);
                this.time -= delta;
            }

            render(ctx, offX, offY) {
                let fx = this.x - offX;
                let fy = this.y - offY;
                ctx.globalAlpha = this.alpha;
                ctx.font = `${this.scale}px Hammersmith One`;
                ctx.fillStyle = this.color;
                ctx.strokeStyle = "#3d3f42";
                ctx.lineWidth = 8;
                ctx.textBaseline = "middle";
                ctx.textAlign = "center";
                ctx.strokeText(this.value, fx, fy);
                ctx.fillText(this.value, fx, fy);
            }
        },
        TextManager: class {
            constructor() {
                this.texts = [];
            }

            addText(x, y, value, type, scale, color, index) {
                const text = new Moddo.modules.AnimText(x, y, value, type, scale, color, index);
                this.texts.push(text);
            }

            update(delta) {
                this.texts = this.texts.filter(text => text.time > 0);
                this.texts.forEach(text => text.update(delta));
            }

            render(ctx, offX, offY) {
                this.texts.forEach(text => text.render(ctx, offX, offY));
                ctx.textBaseline = "alphabetic";
            }
        },
        config: {
            maxScreenWidth: 1920,
            maxScreenHeight: 1080,
            serverUpdateRate: 9,
            tickRate: 1000 / 9,
            maxPlayers: 40,
            maxPlayersHard: 40 + 10,
            collisionDepth: 6,
            minimapRate: 3000,
            colGrid: 10,
            clientSendRate: 5,
            healthBarWidth: 50,
            healthBarPad: 4.5,
            iconPadding: 15,
            iconPad: 0.9,
            deathFadeout: 3000,
            crownIconScale: 60,
            crownPad: 35,
            chatCountdown: 3000,
            chatCooldown: 500,
            inSandbox: window.location.hostname == "sandbox.moomoo.io",
            isSandbox: window.location.hostname == "sandbox.moomoo.io",
            maxAge: 100,
            gatherAngle: pi / 2.6,
            gatherWiggle: 10,
            hitReturnRatio: 0.25,
            hitAngle: pi_2,
            playerScale: 35,
            playerSpeed: 0.0016,
            playerDecel: 0.993,
            nameY: 34,
            skinColors: ["#bf8f54", "#cbb091", "#896c4b", "#fadadc", "#ececec", "#c37373", "#4c4c4c", "#ecaff7", "#738cc3", "#8bc373", "#91b2db", ],
            animalCount: 7,
            aiTurnRandom: 0.06,
            cowNames: ["Sid", "Steph", "Bmoe", "Romn", "Jononthecool", "Fiona", "Vince", "Nathan", "Nick", "Flappy", "Ronald", "Otis", "Pepe", "Mc Donald", "Theo", "Fabz", "Oliver", "Jeff", "Jimmy", "Helena", "Reaper", "Ben", "Alan", "Naomi", "XYZ", "Clever", "Jeremy", "Mike", "Destined", "Stallion", "Allison", "Meaty", "Sophia", "Vaja", "Joey", "Pendy", "Murdoch", "Theo", "Jared", "July", "Sonia", "Mel", "Dexter", "Quinn", "Milky", ],
            shieldAngle: pi_3,
            weaponVariants: [{
                id:  0,
                src:  "",//default
                xp:  0,
                val:  1,
            }, {
                id:  1,
                src:  "_g",//gold
                xp:  3000,
                val:  1.1,
            }, {
                id:  2,
                src:  "_d",//diamond
                xp:  7000,
                val:  1.18,
            }, {
                id:  3,
                src:  "_r",//ruby
                poison:  true,
                xp:  12000,
                val:  1.18,
            }, ],
            weaponXPs: [{
                id:  0,
                xp:  3000,
            }, {
                id:  1,
                xp:  7000,
            }, {
                id:  2,
                xp:  12000,
            }, {
                id:  3,
                xp:  1 / 0,
            }, ],
            fetchVariant: function(player) {
                var tmpXP = player.weaponXP[player.weaponIndex] || 0;
                for (let i = Moddo.modules.config.weaponVariants.length - 1; i >= 0; --i) {
                    if (tmpXP >= Moddo.modules.config.weaponVariants[i].xp) {
                        return Moddo.modules.config.weaponVariants[i];
                    }
                }
            },
            resourceTypes: ["wood", "food", "stone", "points"],
            areaCount: 7,
            treesPerArea: 9,
            bushesPerArea: 3,
            totalRocks: 32,
            goldOres: 7,
            riverWidth: 724,
            riverPadding: 114,
            waterCurrent: 0.0011,
            waveSpeed: 0.0001,
            waveMax: 1.3,
            treeScales: [150, 160, 165, 175],
            bushScales: [80, 85, 95],
            rockScales: [80, 85, 90],
            snowBiomeTop: 2400,
            snowSpeed: 0.75,
            maxNameLength: 15,
            mapScale: 14400,
            mapPingScale: 40,
            mapPingTime: 2200,
            volcanoScale: 320,
            innerVolcanoScale: 100,
            volcanoAnimalStrength: 2,
            volcanoAnimationDuration: 3200,
            volcanoAggressionRadius: 1440,
            volcanoAggressionPercentage: 0.2,
            volcanoDamagePerSecond: -1,
            volcanoLocationX: 14400 - 440,
            volcanoLocationY: 14400 - 440,
        },
        Utils: {
            round: function(n, v) {
                return round(n * v) / v;
            },
            loop: function (action, loop) {
                for (let i = 0; i < loop; i++) {
                    action();
                }
            },
            sFormat: function (num) {
                let fixs = [
                    { num: 1e3, string: "k" },
                    { num: 1e6, string: "m" },
                    { num: 1e9, string: "b" },
                    { num: 1e12, string: "q" }
                ].reverse();
                let sp = fixs.find(v => num >= v.num);
                if (!sp) return num;
                return (num / sp.num).toFixed(1) + sp.string;
            },
            toRad: function (angle) {
                return angle * (pi / 180);
            },
            toAng: function (radian) {
                return radian / (pi / 180);
            },
            randInt: function (min, max) {
                return floor(random() * (max - min + 1)) + min;
            },
            randFloat: function (min, max) {
                return random() * (max - min + 1) + min;
            },
            lerp: function (value1, value2, amount) {
                return value1 + (value2 - value1) * amount;
            },
            decel: function (val, cel) {
                if (val > 0) {
                    val = max(0, val - cel);
                } else if (val < 0) {
                    val = min(0, val + cel);
                }
                return val;
            },
            getDistance: function (x1, y1, x2, y2) {
                return sqrt((x2 -= x1) * x2 + (y2 -= y1) * y2);
            },
            getDist: function (tmp1, tmp2, type1, type2) {
                let tmpXY1 = {
                    x: type1 == 0 ? tmp1.x : type1 == 1 ? tmp1.x1 : type1 == 2 ? tmp1.x2 : type1 == 3 && tmp1.x3,
                    y: type1 == 0 ? tmp1.y : type1 == 1 ? tmp1.y1 : type1 == 2 ? tmp1.y2 : type1 == 3 && tmp1.y3,
                };
                let tmpXY2 = {
                    x: type2 == 0 ? tmp2.x : type2 == 1 ? tmp2.x1 : type2 == 2 ? tmp2.x2 : type2 == 3 && tmp2.x3,
                    y: type2 == 0 ? tmp2.y : type2 == 1 ? tmp2.y1 : type2 == 2 ? tmp2.y2 : type2 == 3 && tmp2.y3,
                };
                return sqrt((tmpXY2.x -= tmpXY1.x) * tmpXY2.x + (tmpXY2.y -= tmpXY1.y) * tmpXY2.y);
            },
            getDirection: function (x1, y1, x2, y2) {
                return atan2(y1 - y2, x1 - x2);
            },
            getDirect: function (tmp1, tmp2, type1, type2) {
                let tmpXY1 = {
                    x: type1 == 0 ? tmp1.x : type1 == 1 ? tmp1.x1 : type1 == 2 ? tmp1.x2 : type1 == 3 && tmp1.x3,
                    y: type1 == 0 ? tmp1.y : type1 == 1 ? tmp1.y1 : type1 == 2 ? tmp1.y2 : type1 == 3 && tmp1.y3,
                };
                let tmpXY2 = {
                    x: type2 == 0 ? tmp2.x : type2 == 1 ? tmp2.x1 : type2 == 2 ? tmp2.x2 : type2 == 3 && tmp2.x3,
                    y: type2 == 0 ? tmp2.y : type2 == 1 ? tmp2.y1 : type2 == 2 ? tmp2.y2 : type2 == 3 && tmp2.y3,
                };
                return atan2(tmpXY1.y - tmpXY2.y, tmpXY1.x - tmpXY2.x);
            },
            getAngleDist: function (a, b) {
                var p = abs(b - a) % (pi2);
                return p > pi ? pi2 - p : p;
            },
            isNumber: function (n) {
                return typeof n == "number" && !isNaN(n) && isFinite(n);
            },
            isString: function (s) {
                return s && typeof s == "string";
            },
            kFormat: function (num) {
                return num > 999 ? (num / 1000).toFixed(1) + "k" : num;
            },
            capitalizeFirst: function (string) {
                return string.charAt(0).toUpperCase() + string.slice(1);
            },
            fixTo: function (n, v) {
                return parseFloat(n.toFixed(v));
            },
            sortByPoints: function (a, b) {
                return parseFloat(b.points) - parseFloat(a.points);
            },
            lineInRect: function (recX, recY, recX2, recY2, x1, y1, x2, y2) {
                let minX = min(x1, x2), maxX = max(x1, x2);
                if (maxX > recX2) maxX = recX2;
                if (minX < recX) minX = recX;
                if (minX > maxX) return false;
                let minY = y1, maxY = y2, dx = x2 - x1;
                if (abs(dx) > 0.0000001) {
                    let a = (y2 - y1) / dx, b = y1 - a * x1;
                    minY = a * minX + b;
                    maxY = a * maxX + b;
                }
                if (minY > maxY) [minY, maxY] = [maxY, minY];
                if (maxY > recY2) maxY = recY2;
                if (minY < recY) minY = recY;
                if (minY > maxY) {
                    return false;
                }
                return true;
            },
            containsPoint: function (element, x, y) {
                var bounds = element.getBoundingClientRect();
                var left = bounds.left + window.scrollX;
                var top = bounds.top + window.scrollY;
                var width = bounds.width;
                var height = bounds.height;
                var insideHorizontal = x > left && x < left + width;
                var insideVertical = y > top && y < top + height;
                return insideHorizontal && insideVertical;
            },
            mousifyTouchEvent: function (event) {
                var touch = event.changedTouches[0];
                event.screenX = touch.screenX;
                event.screenY = touch.screenY;
                event.clientX = touch.clientX;
                event.clientY = touch.clientY;
                event.pageX = touch.pageX;
                event.pageY = touch.pageY;
            },
            hookTouchEvents: function (element, skipPrevent) {
                var preventDefault = !skipPrevent;
                var isHovering = false;
                var passive = false;
                element.addEventListener("touchstart", Moddo.modules.Utils.checkTrusted(touchStart), passive);
                element.addEventListener("touchmove", Moddo.modules.Utils.checkTrusted(touchMove), passive);
                element.addEventListener("touchend", Moddo.modules.Utils.checkTrusted(touchEnd), passive);
                element.addEventListener("touchcancel", Moddo.modules.Utils.checkTrusted(touchEnd), passive);
                element.addEventListener("touchleave", Moddo.modules.Utils.checkTrusted(touchEnd), passive);

                function touchStart(e) {
                    Moddo.modules.Utils.mousifyTouchEvent(e);
                    window.setUsingTouch(true);
                    if (preventDefault) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    if (element.onmouseover) {
                        element.onmouseover(e);
                        isHovering = true;
                    }
                }

                function touchMove(e) {
                    Moddo.modules.Utils.mousifyTouchEvent(e);
                    window.setUsingTouch(true);
                    if (preventDefault) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    if (Moddo.modules.Utils.containsPoint(element, e.pageX, e.pageY)) {
                        if (!isHovering) {
                            if (element.onmouseover) {
                                element.onmouseover(e);
                                isHovering = true;
                            }
                        } else {
                            if (element.onmouseout) {
                                element.onmouseout(e);
                                isHovering = false;
                            }
                        }
                    }
                }
                function touchEnd(e) {
                    Moddo.modules.Utils.mousifyTouchEvent(e);
                    window.setUsingTouch(true);
                    if (preventDefault) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    if (isHovering) {
                        if (element.onclick) {
                            element.onclick(e);
                        }
                        if (element.onmouseout) {
                            element.onmouseout(e);
                            isHovering = false;
                        }
                    }
                }
            },
            removeAllChildren: function(element) {
                while (element.hasChildNodes()) {
                    element.removeChild(element.lastChild);
                }
            },
            generateElement: function(config) {
                var element = document.createElement(config.tag || "div");

                function bind(configValue, elementValue) {
                    if (config[configValue]) {
                        element[elementValue] = config[configValue];
                    }
                }
                bind("text", "textContent");
                bind("html", "innerHTML");
                bind("class", "className");
                for (var key in config) {
                    switch (key) {
                        case "tag":
                        case "text":
                        case "html":
                        case "class":
                        case "style":
                        case "hookTouch":
                        case "parent":
                        case "children":
                            continue;
                        default:
                            break;
                    }
                    element[key] = config[key];
                }
                if (element.onclick) {
                    element.onclick = Moddo.modules.Utils.checkTrusted(element.onclick);
                }
                if (element.onmouseover) {
                    element.onmouseover = Moddo.modules.Utils.checkTrusted(element.onmouseover);
                }
                if (element.onmouseout) {
                    element.onmouseout = Moddo.modules.Utils.checkTrusted(element.onmouseout);
                }
                if (config.style) {
                    element.style.cssText = config.style;
                }
                if (config.hookTouch) {
                    Moddo.modules.Utils.hookTouchEvents(element);
                }
                if (config.parent) {
                    config.parent.appendChild(element);
                }
                if (config.children) {
                    for (let i = 0; i < config.children.length; i++) {
                        element.appendChild(config.children[i]);
                    }
                }
                return element;
            },
            eventIsTrusted: function(ev) {
                if (ev && typeof ev.isTrusted == "boolean") {
                    return ev.isTrusted;
                } else {
                    return true;
                }
            },
            checkTrusted: function(callback) {
                return function(ev) {
                    if (ev && ev instanceof Event && Moddo.modules.Utils.eventIsTrusted(ev)) {
                        callback(ev);
                    } else {
                        console.error("Event is not trusted.", ev);
                    }
                };
            },
            randomString: function(length) {
                var text = "";
                var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                for (let i = 0; i < length; i++) {
                    text += possible.charAt(floor(random() * possible.length));
                }
                return text;
            },
            countInArray: function(array, val) {
                var count = 0;
                for (let i = 0; i < array.length; i++) {
                    if (array[i] === val) {
                        count++;
                    }
                }
                return count;
            },
        },
    },
    msgpack: {
        encode: function (data) {
            const pow32 = 0x100000000;
            let floatBuffer, floatView;
            let array = new Uint8Array(128);
            let length = 0;
            append(data);
            return array.subarray(0, length);

            function append(data) {
                switch (typeof data) {
                    case "undefined":
                        appendNull(data);
                        break;
                    case "boolean":
                        appendBoolean(data);
                        break;
                    case "number":
                        appendNumber(data);
                        break;
                    case "string":
                        appendString(data);
                        break;
                    case "object":
                        if (data === null) {
                            appendNull(data);
                        } else if (data instanceof Date) {
                            appendDate(data);
                        } else if (Array.isArray(data)) {
                            appendArray(data);
                        } else if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
                            appendBinArray(data);
                        } else if (data instanceof Int8Array || data instanceof Int16Array || data instanceof Uint16Array ||
                                   data instanceof Int32Array || data instanceof Uint32Array ||
                                   data instanceof Float32Array || data instanceof Float64Array) {
                            appendArray(data);
                        } else {
                            appendObject(data);
                        }
                        break;
                }
            }

            function appendNull(data) {
                appendByte(0xc0);
            }

            function appendBoolean(data) {
                appendByte(data ? 0xc3 : 0xc2);
            }

            function appendNumber(data) {
                if (isFinite(data) && floor(data) === data) {
                    if (data >= 0 && data <= 0x7f) {
                        appendByte(data);
                    } else if (data < 0 && data >= -0x20) {
                        appendByte(data);
                    } else if (data > 0 && data <= 0xff) { // uint8
                        appendBytes([0xcc, data]);
                    } else if (data >= -0x80 && data <= 0x7f) { // int8
                        appendBytes([0xd0, data]);
                    } else if (data > 0 && data <= 0xffff) { // uint16
                        appendBytes([0xcd, data >>> 8, data]);
                    } else if (data >= -0x8000 && data <= 0x7fff) { // int16
                        appendBytes([0xd1, data >>> 8, data]);
                    } else if (data > 0 && data <= 0xffffffff) { // uint32
                        appendBytes([0xce, data >>> 24, data >>> 16, data >>> 8, data]);
                    } else if (data >= -0x80000000 && data <= 0x7fffffff) { // int32
                        appendBytes([0xd2, data >>> 24, data >>> 16, data >>> 8, data]);
                    } else if (data > 0 && data <= 0xffffffffffffffff) { // uint64
                        let hi = data / pow32;
                        let lo = data % pow32;
                        appendBytes([0xd3, hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);
                    } else if (data >= -0x8000000000000000 && data <= 0x7fffffffffffffff) { // int64
                        appendByte(0xd3);
                        appendInt64(data);
                    } else if (data < 0) { // below int64
                        appendBytes([0xd3, 0x80, 0, 0, 0, 0, 0, 0, 0]);
                    } else { // above uint64
                        appendBytes([0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);
                    }
                } else {
                    if (!floatView) {
                        floatBuffer = new ArrayBuffer(8);
                        floatView = new DataView(floatBuffer);
                    }
                    floatView.setFloat64(0, data);
                    appendByte(0xcb);
                    appendBytes(new Uint8Array(floatBuffer));
                }
            }

            function appendString(data) {
                let bytes = encodeUtf8(data);
                let length = bytes.length;

                if (length <= 0x1f) {
                    appendByte(0xa0 + length);
                } else if (length <= 0xff) {
                    appendBytes([0xd9, length]);
                } else if (length <= 0xffff) {
                    appendBytes([0xda, length >>> 8, length]);
                } else {
                    appendBytes([0xdb, length >>> 24, length >>> 16, length >>> 8, length]);
                }

                appendBytes(bytes);
            }

            function appendArray(data) {
                let length = data.length;
                if (length <= 0xf) {
                    appendByte(0x90 + length);
                } else if (length <= 0xffff) {
                    appendBytes([0xdc, length >>> 8, length]);
                } else {
                    appendBytes([0xdd, length >>> 24, length >>> 16, length >>> 8, length]);
                }
                for (let index = 0; index < length; index++) {
                    append(data[index]);
                }
            }

            function appendBinArray(data) {
                let length = data.length;
                if (length <= 0xf) {
                    appendBytes([0xc4, length]);
                } else if (length <= 0xffff) {
                    appendBytes([0xc5, length >>> 8, length]);
                } else {
                    appendBytes([0xc6, length >>> 24, length >>> 16, length >>> 8, length]);
                }
                appendBytes(data);
            }

            function appendObject(data) {
                let length = 0;
                for (let key in data) length++;
                if (length <= 0xf) {
                    appendByte(0x80 + length);
                } else if (length <= 0xffff) {
                    appendBytes([0xde, length >>> 8, length]);
                } else {
                    appendBytes([0xdf, length >>> 24, length >>> 16, length >>> 8, length]);
                }
                for (let key in data) {
                    append(key);
                    append(data[key]);
                }
            }

            function appendDate(data) {
                let sec = data.getTime() / 1000;
                if (data.getMilliseconds() === 0 && sec >= 0 && sec < 0x100000000) { // 32 bit seconds
                    appendBytes([0xd6, 0xff, sec >>> 24, sec >>> 16, sec >>> 8, sec]);
                } else if (sec >= 0 && sec < 0x400000000) { // 30 bit nanoseconds, 34 bit seconds
                    let ns = data.getMilliseconds() * 1000000;
                    appendBytes([0xd7, 0xff, ns >>> 22, ns >>> 14, ns >>> 6, ((ns << 2) >>> 0) | (sec / pow32), sec >>> 24, sec >>> 16, sec >>> 8, sec]);
                } else { // 32 bit nanoseconds, 64 bit seconds, negative values allowed
                    let ns = data.getMilliseconds() * 1000000;
                    appendBytes([0xc7, 12, 0xff, ns >>> 24, ns >>> 16, ns >>> 8, ns]);
                    appendInt64(sec);
                }
            }

            function appendByte(byte) {
                if (array.length < length + 1) {
                    let newLength = array.length * 2;
                    while (newLength < length + 1) newLength *= 2;
                    let newArray = new Uint8Array(newLength);
                    newArray.set(array);
                    array = newArray;
                }
                array[length] = byte;
                length++;
            }

            function appendBytes(bytes) {
                if (array.length < length + bytes.length) {
                    let newLength = array.length * 2;
                    while (newLength < length + bytes.length) newLength *= 2;
                    let newArray = new Uint8Array(newLength);
                    newArray.set(array);
                    array = newArray;
                }
                array.set(bytes, length);
                length += bytes.length;
            }

            function appendInt64(value) {
                let hi, lo;
                if (value >= 0) {
                    hi = floor(value / pow32);
                    lo = value % pow32;
                } else {
                    hi = floor(value / pow32);
                    lo = value % pow32;
                }
                appendBytes([0xd3, hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);
            }

            function encodeUtf8(data) {
                let length = data.length;
                let bytes = [];
                for (let i = 0; i < length; i++) {
                    let charCode = data.charCodeAt(i);
                    if (charCode < 0x80) {
                        bytes.push(charCode);
                    } else if (charCode < 0x800) {
                        bytes.push(0xc0 | (charCode >> 6));
                        bytes.push(0x80 | (charCode & 0x3f));
                    } else if (charCode < 0xd800 || charCode >= 0xe000) {
                        bytes.push(0xe0 | (charCode >> 12));
                        bytes.push(0x80 | ((charCode >> 6) & 0x3f));
                        bytes.push(0x80 | (charCode & 0x3f));
                    } else {
                        i++;
                        charCode = ((charCode & 0x3ff) << 10) | (data.charCodeAt(i) & 0x3ff);
                        bytes.push(0xf0 | (charCode >> 18));
                        bytes.push(0x80 | ((charCode >> 12) & 0x3f));
                        bytes.push(0x80 | ((charCode >> 6) & 0x3f));
                        bytes.push(0x80 | (charCode & 0x3f));
                    }
                }
                return bytes;
            }
        },

        decode: function (array) {
            const pow32 = 0x100000000; // 2^32
            let pos = 0;
            if (array instanceof ArrayBuffer) {
                array = new Uint8Array(array);
            }
            if (typeof array !== "object" || typeof array.length === "undefined") {
                throw new Error("Invalid argument type: Expected a byte array (Array or Uint8Array) to deserialize.");
            }
            if (!array.length) {
                throw new Error("Invalid argument: The byte array to deserialize is empty.");
            }
            if (!(array instanceof Uint8Array)) {
                array = new Uint8Array(array);
            }
            let data = read();
            if (pos < array.length) {
            }
            return data;
            function read() {
                const byte = array[pos++];
                if (byte >= 0x00 && byte <= 0x7f) return byte; // positive fixint
                if (byte >= 0x80 && byte <= 0x8f) return readMap(byte - 0x80); // fixmap
                if (byte >= 0x90 && byte <= 0x9f) return readArray(byte - 0x90); // fixarray
                if (byte >= 0xa0 && byte <= 0xbf) return readStr(byte - 0xa0); // fixstr
                if (byte === 0xc0) return null; // nil
                if (byte === 0xc1) throw new Error("Invalid byte code 0xc1 found."); // never used
                if (byte === 0xc2) return false // false
                if (byte === 0xc3) return true; // true
                if (byte === 0xc4) return readBin(-1, 1); // bin 8
                if (byte === 0xc5) return readBin(-1, 2); // bin 16
                if (byte === 0xc6) return readBin(-1, 4); // bin 32
                if (byte === 0xc7) return readExt(-1, 1); // ext 8
                if (byte === 0xc8) return readExt(-1, 2); // ext 16
                if (byte === 0xc9) return readExt(-1, 4) // ext 32
                if (byte === 0xca) return readFloat(4); // float 32
                if (byte === 0xcb) return readFloat(8); // float 64
                if (byte === 0xcc) return readUInt(1); // uint 8
                if (byte === 0xcd) return readUInt(2); // uint 16
                if (byte === 0xce) return readUInt(4); // uint 32
                if (byte === 0xcf) return readUInt(8) // uint 64
                if (byte === 0xd0) return readInt(1); // int 8
                if (byte === 0xd1) return readInt(2); // int 16
                if (byte === 0xd2) return readInt(4); // int 32
                if (byte === 0xd3) return readInt(8); // int 64
                if (byte === 0xd4) return readExt(1); // fixext 1
                if (byte === 0xd5) return readExt(2); // fixext 2
                if (byte === 0xd6) return readExt(4); // fixext 4
                if (byte === 0xd7) return readExt(8); // fixext 8
                if (byte === 0xd8) return readExt(16); // fixext 16
                if (byte === 0xd9) return readStr(-1, 1); // str 8
                if (byte === 0xda) return readStr(-1, 2); // str 16
                if (byte === 0xdb) return readStr(-1, 4); // str 32
                if (byte === 0xdc) return readArray(-1, 2); // array 16
                if (byte === 0xdd) return readArray(-1, 4); // array 32
                if (byte === 0xde) return readMap(-1, 2); // map 16
                if (byte === 0xdf) return readMap(-1, 4); // map 32
                if (byte >= 0xe0 && byte <= 0xff) return byte - 256; // negative fixint
                console.debug("msgpack array:", array);
                throw new Error("Invalid byte value '" + byte + "' at index " + (pos - 1) + " in the MessagePack binary data (length " + array.length + "): Expecting a range of 0 to 255. This is not a byte array.");
            }
            function readInt(size) {
                let value = 0;
                let first = true;
                while (size-- > 0) {
                    if (first) {
                        let byte = array[pos++];
                        value += byte & 0x7f;
                        if (byte & 0x80) {
                            value -= 0x80;
                        }
                        first = false;
                    }
                    else {
                        value *= 256;
                        value += array[pos++];
                    }
                }
                return value;
            }
            function readUInt(size) {
                let value = 0;
                while (size-- > 0) {
                    value *= 256;
                    value += array[pos++];
                }
                return value;
            }
            function readFloat(size) {
                let view = new DataView(array.buffer, pos, size);
                pos += size;
                if (size === 4) {
                    return view.getFloat32(0, false);
                }
                if (size === 8) {
                    return view.getFloat64(0, false);
                }
            }
            function readBin(size, lengthSize) {
                if (size < 0) size = readUInt(lengthSize);
                let data = array.subarray(pos, pos + size);
                pos += size;
                return data;
            }
            function readMap(size, lengthSize) {
                if (size < 0) size = readUInt(lengthSize);
                let data = {};
                while (size-- > 0) {
                    let key = read();
                    data[key] = read();
                }
                return data;
            }
            function readArray(size, lengthSize) {
                if (size < 0) size = readUInt(lengthSize);
                let data = [];
                while (size-- > 0) {
                    data.push(read());
                }
                return data;
            }
            function readStr(size, lengthSize) {
                if (size < 0) size = readUInt(lengthSize);
                let start = pos;
                pos += size;
                return decodeUtf8(array, start, size);
            }
            function readExt(size, lengthSize) {
                if (size < 0) size = readUInt(lengthSize);
                let type = readUInt(1);
                let data = readBin(size);
                switch (type) {
                    case 255:
                        return readExtDate(data);
                }
                return { type: type, data: data };
            }
            function readExtDate(data) {
                if (data.length === 4) {
                    let sec = ((data[0] << 24) >>> 0) +
                        ((data[1] << 16) >>> 0) +
                        ((data[2] << 8) >>> 0) +
                        data[3];
                    return new Date(sec * 1000);
                }
                if (data.length === 8) {
                    let ns = ((data[0] << 22) >>> 0) +
                        ((data[1] << 14) >>> 0) +
                        ((data[2] << 6) >>> 0) +
                        (data[3] >>> 2);
                    let sec = ((data[3] & 0x3) * pow32) +
                        ((data[4] << 24) >>> 0) +
                        ((data[5] << 16) >>> 0) +
                        ((data[6] << 8) >>> 0) +
                        data[7];
                    return new Date(sec * 1000 + ns / 1000000);
                }
                if (data.length === 12) {
                    let ns = ((data[0] << 24) >>> 0) +
                        ((data[1] << 16) >>> 0) +
                        ((data[2] << 8) >>> 0) +
                        data[3];
                    pos -= 8;
                    let sec = readInt(8);
                    return new Date(sec * 1000 + ns / 1000000);
                }
                throw new Error("Invalid data length for a date value.");
            }

            function encodeUtf8(str) {
                let ascii = true, length = str.length;
                for (let x = 0; x < length; x++) {
                    if (str.charCodeAt(x) > 127) {
                        ascii = false;
                        break;
                    }
                }
                let i = 0, bytes = new Uint8Array(str.length * (ascii ? 1 : 4));
                for (let ci = 0; ci !== length; ci++) {
                    let c = str.charCodeAt(ci);
                    if (c < 128) {
                        bytes[i++] = c;
                        continue;
                    }
                    if (c < 2048) {
                        bytes[i++] = c >> 6 | 192;
                    }
                    else {
                        if (c > 0xd7ff && c < 0xdc00) {
                            if (++ci >= length) throw new Error("UTF-8 encode: incomplete surrogate pair");
                            let c2 = str.charCodeAt(ci);
                            if (c2 < 0xdc00 || c2 > 0xdfff) throw new Error("UTF-8 encode: second surrogate character 0x" + c2.toString(16) + " at index " + ci + " out of range");
                            c = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
                            bytes[i++] = c >> 18 | 240;
                            bytes[i++] = c >> 12 & 63 | 128;
                        }
                        else bytes[i++] = c >> 12 | 224;
                        bytes[i++] = c >> 6 & 63 | 128;
                    }
                    bytes[i++] = c & 63 | 128;
                }
                return ascii ? bytes : bytes.subarray(0, i);
            }
            function decodeUtf8(bytes, start, length) {
                let i = start, str = "";
                length += start;
                while (i < length) {
                    let c = bytes[i++];
                    if (c > 127) {
                        if (c > 191 && c < 224) {
                            if (i >= length) throw new Error("UTF-8 decode: incomplete 2-byte sequence");
                            c = (c & 31) << 6 | bytes[i++] & 63;
                        }
                        else if (c > 223 && c < 240) {
                            if (i + 1 >= length) throw new Error("UTF-8 decode: incomplete 3-byte sequence");
                            c = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
                        }
                        else if (c > 239 && c < 248) {
                            if (i + 2 >= length) throw new Error("UTF-8 decode: incomplete 4-byte sequence");
                            c = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
                        }
                        else throw new Error("UTF-8 decode: unknown multibyte start 0x" + c.toString(16) + " at index " + (i - 1));
                    }
                    if (c <= 0xffff) str += String.fromCharCode(c);
                    else if (c <= 0x10ffff) {
                        c -= 0x10000;
                        str += String.fromCharCode(c >> 10 | 0xd800)
                        str += String.fromCharCode(c & 0x3FF | 0xdc00)
                    }
                    else throw new Error("UTF-8 decode: code point 0x" + c.toString(16) + " exceeds UTF-16 reach");
                }
                return str;
            }
        },
    },
};
Moddo.main();
